[{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"真的是服了，苹果自动更新的IOS17，本来没感觉有什么，但是今天要用虚拟定位的时候才发现，IOS 17居然没法成功启用（爱思助手），冲浪了一圈才发现是因为IOS17做了重大更改，导致原来的虚拟定位功能机制变更，无法使用当前版本的爱思助手进行虚拟定位，网上找了一圈才发现支持IOS17的主流虚拟定位软件（anygo）收费真他娘的黑啊，一个月19美金。。。。，免费的方案倒是有，但是折腾了挺久也没成功，传送门是这个https://github.com/RManLuo/FakePosition，包括看了他的上游方案也不行，emmmmmm，真的是F**K Apple了！\nimpressionyang\r","date":"October 19, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/fuck_ios_17_001/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"IOS","url":"/tags/ios/"},{"title":"dialy","url":"/tags/dialy/"}],"timestamp":1697687016,"title":"抽风的IOS 17 体验"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"Windows on Arm APP 推荐1\r本文用来记录购买huawei matebook e go后转入使用Windows On ARM系统的一些ARM架构的APP的心得\n楔子\r本月购入了huawei matebook e go，这是一个二合一的windows 平板，搭载高通骁龙8cx gen3的处理器，运行win11 ARM版，所以使用过程中会针对ARM架构的原生APP进行关注，立贴收集。\n今天收集了两款软件\nobsidian vscode obsidian\robsidian是我用来进行日记记录和整理的工具，非常好用，没想到居然有ARM版本的，传送门如下：\nhttps://obsidian.md/download\n下载后安装即可正常使用\nvscode\rVSCode是我们程序员最喜欢的文本编辑器，可以通过插件的方式来扩充很多功能提高开发的效率，让我们的代码编辑体验得到很大的提升，这个程序目前也提供了ARM版本的安装包，传送门如下：\nhttps://code.visualstudio.com/#alt-downloads\n结语\r在Windows On Arm下还是比较倾向于使用原生架构的程序的，不管是出于运行效率还是功耗上来看。因为原生的总会比转译的程序运行得更加舒服是吧。\nimpressionyang\r","date":"September 20, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/windows-on-arm-apps-1/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"WOA","url":"/tags/woa/"},{"title":"app","url":"/tags/app/"}],"timestamp":1695219898,"title":"Windows on Arm APP 推荐1"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"在Linux中运行Elegoo Cura 3D切片软件\r该文章用于记录在Linux下使用Wine来运行Windows版本的Elegoo的定制Cura 3D切片软件\nCura是什么软件\r在FDM（FDM是“Fused Deposition Modeling”的缩写，即熔积成型法，是一种将各种丝材（如工程塑料ABS、聚碳酸酯PC 等）3D加热熔化进而堆积成型方法）打印的圈子里面大家经常使用到的切片软件就是Cura,所谓切片，就是将一个3D模型按照打印机的打印机制将其切成一个个平面进行编辑打印路径，然后合成一个路径文件即GCode文件，将该文件导入打印机后即可启动3D打印。\nElegoo Cura软件界面 如何获取Cura\r官方版本\rCura的官方版本是Ultimaker Cura，直接在官网下载即可，传送门，官方版本是直接支持Linux的。\nelegoo定制版本\rElegoo的官方版本上面并没有提供Linux版本的程序，官网传送门\n如何安装Cura到Linux中\r环境准备\rwine安装\r在Linux中使用Elegoo的Cura软件的一个很好的思路就是使用wine来运行Windows版本的Elegoo Cura, 生成切片文件后通过内网或者U盘吧GCode文件上传到打印机中使用，所以安装Wine是第一步。\n我这里使用的是Manjaro Linux,是Arch系列的，其他发行版的逻辑也差不多，使用对应的方式来安装Wine即可。\nArch Base Linux 1sudo pacman -S wine winetrics安装\rwinetricks是wine的配置化工具，可以提供一个统一的界面来配置和安装程序，安装后可以提高使用wine的体验感\nArch Base Linux 1sudo pacman -S winetricks 软件安装\rElegoo Cura安装\r使用winetricks的文件管理器来打开Elegoo Cura，执行安装步骤\n运行winetricks，选择创建容器\n在容器中打开文件管理器\n在文件管理器中双击Elegoo的Cura软件（中文显示有点问题）\n执行完安装步骤即可\n在安装的映射路径中直接双击Cura运行程序即可运行Elegoo Cura\n切片打印\r切片体验\r启动软件后，设置参数，即可进行切片和预览了\n导入模型\n设置参数\n预览切片\n打印体验\r然后吧Gcode文件导入打印机打印即可\n打印后组装\nimpressionyang\r","date":"June 15, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/running_elegoo_cura_in_linux/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"3D","url":"/tags/3d/"},{"title":"cura","url":"/tags/cura/"},{"title":"elegoo","url":"/tags/elegoo/"}],"timestamp":1686760884,"title":"在Linux中运行Elegoo Cura 3D切片软件"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"FreeCAD 离线手动安装插件的方法\r该文档从FreeCAD的官方文档Installing more workbenches小节中获取，记录用于后续查找\n插件从哪里获取\r插件从Github上获取，传送门\n插件安装位置\r从github上获取到想要的插件后，解压放到对应的位置即可\n安装到系统全局位置\r如果想要所有人都能够读取到插件的话，就安装到系统全局的位置\nLinux系统基本是： /usr/share/freecad/Mod/ Windows系统基本是： C:\\Program Files\\FreeCAD\\Mod\\ Mac系统基本是： /Applications/FreeCAD/Mod/ 安装到个人目录位置\r如果只需要个人使用目的的话，安装在个人目录则比较安全\n个人目录下的话，一般都是如下位置\nLinux系统基本是： /home/username/.local/share/FreeCAD/Mod/ (版本大于 0.20 ) 或者在 /home/username/.FreeCAD/Mod/ (版本小于 0.19 ) Windows系统基本是： C:\\Users\\username\\Appdata\\Roaming\\FreeCAD\\Mod\\ Mac系统基本是： /Users/username/Library/Preferences/FreeCAD/Mod/. 解压后基本如下（我是Linux系统）\n使用\r解压到对应位置后重启FreeCAD即可查看安装的插件\nimpressionyang\r","date":"June 8, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/freecad_install_addons/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"FreeCAD","url":"/tags/freecad/"}],"timestamp":1686155015,"title":"FreeCAD 离线手动安装插件的方法"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"为什么我使用HomeAssistant并且使用HAOS\r以下称HomeAssistant为HA，至于为什么写这篇文章则是为了让我哪天怀疑我为什么使用HA的时候回首拾回初心吧（或许也不会[bush]）\n为什么是HA\r我是一个开源拥护者，因为开源意味着可以白嫖（bushi），可以对相关的安全性和隐私性有比较好的把握。本来我打算搭建的智能家居系统是华为的智慧家居的，但是因为成本和生态链的原因放弃了。\n其实还有一部分的原因是我希望我能够对自己的智能家居系统有绝对的掌控权，并且能够自己开发相应的插件集成到这个系统中。很明显，在米家、华为智慧生活等国产的智能家居的方案中是很难达成的。\nHA已经是一个成熟的、经过很多人验证的智能家居管理系统了，其稳定性、可操作性、文档支持等一定是非常到位的，所以我选择无脑冲233。\n为什么用HAOS\r使用HA的方式有很多，例如：\ndocker 虚拟机 PVE 实体机 等等等等 我个人比较喜欢吧这种专用的功能集合放在一个物理机里面，这样能够保证我能够单独对其进行维护而不必考虑其他的内容的影响，所以还是直接在实体机里面安装HAOS才是我最喜欢的方式。\n我使用的实体机是一个淘的二手J1900处理器的瘦客户机，资源大概如下：\nCPU：Intel J1900 RAM：4GB DDR3 1600 DISK：120GB UDisk（OS）：32GB 整机功耗平时也就7W左右，基本不耗多少电。\n如果你非要问为啥不用树莓派等arm方案的平台，则是因为我需要有一些编译需求如ESPHome的固件生成等操作需要对性能有些要求，并且X86_X64架构的HAOS支持更多的插件，和树莓派相比，功耗也不会太高、性能甩几条街、价格也是相对树莓派的天价也是低了很多，所以这已经不是选择题了，我是垃圾佬我快乐（280 RMB的快乐）。\n完事了，撤。\nimpressionyang\r","date":"April 23, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/why_i_use_home_assitant_and_haos/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"HAOS","url":"/tags/haos/"},{"title":"homeassistant","url":"/tags/homeassistant/"}],"timestamp":1682265559,"title":"为什么我使用HomeAssistant并且使用HAOS"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"x86_x64系统安装HAOS\r本文引用自HomeAsisstant官网内容，地址为：https://www.home-assistant.io/installation/generic-x86-64 , 下面称呼Home Assistant Operating System为HAOS\n本文是为了使用一个单独的硬件来运行HAOS, 让HAOS完全使用硬件的性能来完成管理功能，不适合想用容器或supervisor方式体验的人参考，切记！\n安装环境\r我选择安装的机器是一个X86_X64的瘦客户机，使用Intel J1900处理器， 4G内存，120G存储，本次使用它来进行HAOS的安装，但是安装过程中还是有些问题。\n目前（截止本文2023/04） HAOS的安装方式仍旧非常诡异，需要在一个操作系统下使用一个Balena Etcher的安装工具来进行安装，这个安装器\n我在Live系统中尝试使用安装器来进行安装HAOS时发现，机器自带的硬盘在Linux的Live系统下会认为这个硬盘属于系统盘，无法进行安装至该硬盘，所以我只能寻求其他方式，将HAOS安装至U盘中（没办法，暂且这样吧QAQ）\n安装前准备\r安装HAOS前需要满足以下条件：\n可以运行Balena Etcher的环境：如Linux Live系统、完全可运行的系统（Linux、Windows） HAOS的网路环境可连通，用于在网络URL条件下安装HAOS，当然，也可以将镜像先下载下来 一个除了系统盘外可用的硬盘（后续如果有解决方案再更新） 安装系统\r在系统环境中运行Balena Etcher，选择镜像位置（可选URL和本地镜像）\nURL位置为（截止本文2023/04）：https://github.com/home-assistant/operating-system/releases/download/10.0/haos_generic-x86-64-10.0.img.xz 然后选择安装的硬盘位置\n然后点击Flash进行安装即可\n烧写完成后如下所示\n基本上完成以上步骤后即可重新启动HAOS机器，等待HAOS启动了\n访问HAOS\rHAOS系统启动后可以通过以下来两种方式访问：\nip访问：通过路由器后台查看homeassistant设备的ip地址，然后通过http://ip:8123访问即可 域名访问：一般网络环境正常也可以通过http://homeassistant.local:8123 impressionyang","date":"April 20, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/haos_x86_x64_install/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"HAOS","url":"/tags/haos/"},{"title":"homeassistant","url":"/tags/homeassistant/"}],"timestamp":1681925554,"title":"X86_x64系统安装HAOS"},{"authors":[],"categories":[],"content":"ESP32系列板子工程\rESP32 S2 FH4 核心板\r项目地址：https://oshwhub.com/impressionyang/esp32_s2_fh4_test_001\n项目简介：\n该项目已经打板验证OK 带有3D结构 ESP32\rimpressionyang\r","date":"January 28, 2023","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/workspace/esp_32_serials_board/","series":[{"title":"项目","url":"/series/%E9%A1%B9%E7%9B%AE/"}],"smallImg":"","tags":[{"title":"git","url":"/tags/git/"},{"title":"JLC","url":"/tags/jlc/"},{"title":"esp32","url":"/tags/esp32/"},{"title":"repo","url":"/tags/repo/"}],"timestamp":1674891553,"title":"ESP32系列板子工程"},{"authors":[],"categories":[{"title":"book","url":"/categories/book/"}],"content":"《掌中花园 无穷小亮的栽培心得与技巧》 张辰亮著\r书籍信息\r作者： 张晨亮\n出版社：中国国家地理\n我的阅读感受\r这是一本非常好的微型植物养护入门的书籍，虽然我现在还没有进行实践，但是并不妨碍我从里面学习很多的微观造景知识，所以，个人非常推荐在闲暇的时候进行阅读。\nimpressionyang\r","date":"January 28, 2023","img":"https://img11.360buyimg.com/n7/jfs/t1/51950/35/20776/105281/636c8a4dE3e83e1dc/d26fcd08881176c1.jpg","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/book/garden_in_the_palm/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"book","url":"/tags/book/"},{"title":"dialy","url":"/tags/dialy/"},{"title":"notes","url":"/tags/notes/"}],"timestamp":1674890026,"title":"《掌中花园 无穷小亮的栽培心得与技巧》 张辰亮著"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":" 该文档用来记录简单使用openOCD过程，使用的是CMSIS DAPLink（该link很便宜，并且开源正版）\nopenOCD是一个用来进行在线调试的工具，它配合GDB和对应的芯片的SVD文件根据调试工具（stlink、jlink、CMSIS DAPLink等）的配置可以对嵌入式单片机MCU进行在线调试\n安装openOCD\r该工具在windows和类Unix系统下的安装有所不同，下面一一列举\nwindows\r在windows下安装openOCD可以直接安装exe文件，也可以直接下载可执行文件直接运行，我个人比较推荐后者，下面是我放在蓝奏云上的openOCD的可执行文件\n蓝奏云\n提取码：8vve 地址：https://impressionyang.lanzoum.com/ic3sU014w01e 下载后将openOCD添加到PATH环境变量,在控制台中输入openocd --version能看到版本相关信息即可\nLinux/Unix/MacOS\r也是直接用包管理工具安装，Archlinux如下：\n1sudo pacman -S openocd 在控制台中输入openocd --version能看到版本相关信息即可\n启动openOCD\r举例启动openOCD连接一个STM32F103C8T6的板子 1openocd -f interface/cmsis-dap.cfg -f target/stm32f1x.cfg 链接openOCD\rwindows如果找不到telnet的话根据该链接内容打开telnet 点击跳转，下面摘录防连接失效\n1 作为个人用户Telnet还是非常方便的。安装Win7Telnet和WindowsServer2008略有不同，大家可以通过下面的操作方法实现。依次点击“开始”→“控制面板”→“程序”，“在程序和功能”找到并点击“打开或关闭Windows功能”进入Windows功能设置对话框。找到并勾选“Telnet客户端”和“Telnet服务器”，最后“确定”稍等片刻 即可完成安装。除此之外，我们也可通过该向导安装“TFTP客户端”、“Internet信息服务”等。 2 3 安装完成后，Telnet服务默认情况下是禁用的。还需执行“开始”→“运行”，输入servcies.msc打开服务管理器。找到并双击Telnet服务项，设置其启动方式为“手动”(更安全，只在需要的时候才启用)，最后“启动”该服务“确定”退出即可。 另外运行一个控制台去运行telnet链接openOCD 1telnet localhost 4444 使用openOCD烧录固件\r仅列举烧录功能，调试功能需要配合不同的gdb进行，等以后再讲相关的内容\n1halt #停止软件运行 2flash write_image erase /path/to/hex_file.hex #烧录软件 3reset # 复位芯片 4exit # 退出openOCD impressionyang","date":"March 19, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/how_to_use_openocd/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"embedded","url":"/tags/embedded/"},{"title":"debug","url":"/tags/debug/"},{"title":"tool","url":"/tags/tool/"}],"timestamp":1647702457,"title":"如何使用openOCD"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":" 该文章用来记录移植RT Thread的过程记录，本次移植基于STM32 F103C8T6，使用STM32 CubeMX工具构建HALL库的Makefile工程。\n环境\r开发板：STM32F103C8T6最小开发板之一 操作系统：Linux 开发环境：VSCode 编译工具：GCC Makefile 烧录工具：CMSIS DAP + openOCD 构建Makefile工程\r首先在构建工具STM32 CubeMX创建STM3F103的工程，如下图 然后配置好对应的引脚时钟和外围，随后导出一个Makefile工程 工程如下，因为使用了USB和stm32 CubeMX来构建工程，所以会生成如下的目录结构 1. 2├── Core 3├── Drivers 4├── Makefile 5├── Middlewares 6├── startup_stm32f103xb.s 7├── stm32f103c8t6_bare.ioc 8├── STM32F103C8Tx_FLASH.ld 9└── USB_DEVICE 10 114 directories, 4 files 接下来相关的移植操作就会在这个工程的基础上进行\n获取RT Thread Nano资源\rRT Thread的资源位于其官方的github仓库中,点击获取官网提供版本\n下载下来的RT Thread Nano的官网版本目录结构如下 1. 2├── AUTHORS 3├── bsp 4├── ChangeLog.md 5├── components 6├── docs 7├── include 8├── libcpu 9├── LICENSE 10├── README.md 11└── src 12 136 directories, 4 files 接下来会使用其中的主要文件夹为\ncomponents：组件文件夹，主要使用其中的finsh组件，这个是一个命令行控制组件 include：头文件相关文件夹，RT Thread的主要文件之一 libcpu：MCU资源移植文件夹，用来是的MCU能够 完美支持RT Thread去运行 src：源文件相关文件夹，RT Thread的主要文件之一 移植RT Thread的一些要点简述\r主要的移植要点都在这里，下面讲的都是大致内容 移植过程基本分为下面几步：\n添加 Nano 源文件 配置工程相关内容 上述的内容即为\n开始移植\r移植前我已经在项目中添加了一个闪灯的功能，等移植完毕后也会和移植前有一样的效果 文件拷贝\r根据上述的内容说明，我们应该将文件夹components、include、libcpu、src的内容悉数移动过来，但是也有一些其他内容需要注意，基本如下步骤\n移动相关文件夹 移动相关文件 context_gcc.s：该文件是用来控制上下文切换（例如线程切换）时要做的操作，一般是使用芯片原厂提供的内容 board.c：这个文件是用来实现一些RT_Thread的一些要求的函数，如系统时钟初始化，滴答计时器中断实现等 rtconfig.h：该文件用于配置RT thread的功能开启和关闭的 项目配置\r和项目配置相关的内容有两个，分别是项目的源文件配置和项目的配置文件配置\n源文件配置\r源文件的配置一般是相关中断的配置和项目配置文件，所以做如下的配置 启动文件配置 该动作是用来让RT_Thread取代裸机main为启动入口的功能，先进入entry来启动RT_Thread，然后在新线程中调用main功能\nrtconfig.h文件配置 目前保持默认，finsh关闭\nstm32f1xx_it.c的中断配置 需要注释掉的中断分别为如下几个\nvoid HardFault_Handler(void)：硬件错误中断处理函数 void PendSV_Handler(void)：任务切换处理函数 void SysTick_Handler(void)：系统滴答定时器中断处理函数 项目配置文件配置\r本次使用Makefile文件来管理项目，所以配置的是Makefile文件内容，基本上 原理就是添加对应的源文件，如下图：\n注意：在此处我将汇编文件context_gcc.S文件名改成了小写后缀的context_gcc.s，因为大写的S不符合后续的Makefile规则\n测试运行\r使用make编译完成后在build文件夹中将elf文件通过openOCD烧录进板子中后可以达成运行效果\n移植finsh\rfinsh是RT_Thread中的一个比较有特点的组件，目前的RT_Thread Nano中支持了该组件的移植，因为该组件依赖的功能不多\n移植步骤\r复制代码 配置项目 编辑源文件 测试 复制代码\r之前的复制RT_Thread的源文件的过程中，components中的内容就是finsh的源代码\n配置项目\r需要配置的项目文件有：\nMakefile：添加finsh的头文件包含和源文件内容 链接文件：添加finsh遗漏的链接函数声明和RT_Thread的初始化函数声明 添加的内容 1 /* section information for finsh shell */ 2 . = ALIGN(4); 3 __fsymtab_start = .; 4 KEEP(*(FSymTab)) 5 __fsymtab_end = .; 6 . = ALIGN(4); 7 __vsymtab_start = .; 8 KEEP(*(VSymTab)) 9 __vsymtab_end = .; 10 . = ALIGN(4); 11 12 /* section information for initial. */ 13 . = ALIGN(4); 14 __rt_init_start = .; 15 KEEP(*(SORT(.rti_fn*))) 16 __rt_init_end = .; 17 . = ALIGN(4); 编辑源文件\r编辑源文件需要的内容如下：\n添加基本的控制台输出和配置 添加finsh msh的配置 添加finsh msh相关的控制台输入 添加finsh生效的链接文件内容 添加基本的控制台输出和配置\r如果只是使用finsh作为基本的输出而不需要输入的话（也就是只使用rt_kprintf()函数），只需要做简单的配置就可以实现\n配置rtconfig.h 实现控制台输出函数，该函数的功能是从串口输出一个字符 1void rt_hw_console_output(const char *str) 2{ 3 rt_size_t i = 0, size = 0; 4 char a = \u0026#39;\\r\u0026#39;; 5 6 __HAL_UNLOCK(\u0026amp;huart1); 7 8 size = rt_strlen(str); 9 for (i = 0; i \u0026lt; size; i++) 10 { 11 if (*(str + i) == \u0026#39;\\n\u0026#39;) 12 { 13 HAL_UART_Transmit(\u0026amp;huart1, (uint8_t *)\u0026amp;a, 1, 1); 14 } 15 HAL_UART_Transmit(\u0026amp;huart1, (uint8_t *)(str + i), 1, 1); 16 } 17} 然后使用函数rt_kprintf()当作printf功能输出即可\n添加finsh msh的配置\r配置如下：\n在#if defined(RTE_USING_FINSH)之前添加#define RTE_USING_FINSH，因为我们的Makefile工程不需要rte配置文件（MDK中的才有）\n添加finsh msh相关的控制台输入\r在控制台输出函数的下方加入以下代码即可，该函数功能是从串口获取一个字符 1char rt_hw_console_getchar(void) 2{ 3 int ch = -1; 4 5 if (__HAL_UART_GET_FLAG(\u0026amp;huart1, UART_FLAG_RXNE) != RESET) 6 { 7 ch = huart1.Instance-\u0026gt;DR \u0026amp; 0xff; 8 } 9 else 10 { 11 rt_thread_mdelay(10); 12 } 13 return ch; 14} 添加finsh生效的链接文件内容\r因为在与其他的工程的链接文件的对比中法相，使用STM32CubeMX生成的工程的链接文件中没有添加相关的一些内容，已经在上面说明，不再赘述\n测试\r基本上做完上面的内容后finsh就可以生效了\nimpressionyang","date":"February 13, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/rt_thread_nano_port_stm32_f103c8t6/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"RT_Thread","url":"/tags/rt_thread/"},{"title":"C","url":"/tags/c/"},{"title":"porting","url":"/tags/porting/"},{"title":"gcc","url":"/tags/gcc/"}],"timestamp":1644724230,"title":"Stm32_f103c8t6 RT Thread 移植笔记"},{"authors":[],"categories":[],"content":"W806 的Makefile工程\r该代码仓库是用来收集和修改来自各位大佬的关于W806的板子的项目的，其主要的目的就是在Linux下使用Makefile来进行编译项目\nMakefile工程支持如果原项目不支持的话有本人进行Makefile构建\n项目\r项目地址\r项目的地址传送门\n项目简介\r介绍\r该项目是根据RCSN的项目修改而来，同样是基于W800的Makefile项目裁剪\n由于RCSN的Makefile有一些问题导致无法编译见此处，所以对Makefile进行了修改，现在可以正常编译 使用说明\rgit clone git@gitee.com:impressionyang/w806_makefile.git cd w806_makefile 配置工具链： Linux/Unix: export PATH=$PATH:path_to_csky_toolchain_bin (注意此处的path_to_csky_toolchain_bin为csky的编译工具链的bin文件夹路径) Windows: 请将csky的编译工具链的bin文件夹路径添加到环境变量中 make Vscode Task注意根据自己的需求修改\n目前收录内容\rW806的裸机工程Makefile项目 W806的RT_Thread的Makefile工程 说明\r该项目仅用于学习使用，完全免费，大家一起来进行学习\nimpressionyang","date":"January 7, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/workspace/w806_makefile/","series":[{"title":"项目","url":"/series/%E9%A1%B9%E7%9B%AE/"}],"smallImg":"","tags":[{"title":"git","url":"/tags/git/"},{"title":"gitee","url":"/tags/gitee/"},{"title":"W806","url":"/tags/w806/"},{"title":"repo","url":"/tags/repo/"}],"timestamp":1641569004,"title":"W806_makefile"},{"authors":[],"categories":[],"content":"说明\r本文主要说明在Arch系下安装VM Ware增强工具，因为同时想用dde+pacman，所以想折腾一下manjaro deepin，作此总结。\n本文主要基于archwiki的指导进行：VMware/Install Arch Linux as a guest\n需要安装的工具\ropen-vm-tools ：vmware官方开源的部分驱动 xf86-input-vmmouse ： vmware下的输入增强 xf86-video-vmware ：vmware下的显示增强 mesa ： 通用显示驱动 gtkmm3 ：保证拖拽和复制相关 gtkmm和gtk2 ：窗口自适应依赖 一键安装命令\n1suda pacman -s open-vm-tools xf86-input-vmmouse xf86-video-vmware mesa gtkmm3 gtkmm gtk2 配置\r开机自启动\r1sudo systemctl enable vmtoolsd 显示\r配置Xorg\n1sudo vi /etc/X11/Xwrapper.config 添加如下内容\n1needs_root_rights=yes 拖拽和复制\r1sudo cp /etc/vmware-tools/vmware-user.desktop /etc/xdg/autostart/vmware-user.desktop 重启即可尝试使用了\r1reboot 收尾\r因为VM官方的VMTools在arch系下的安装脚本是有问题的，会卡在选择init上，因为arch系列并不使用这一机制，所以还是使用这一方案，总体来说还是能够满足日常使用需求的。\nimpressionyang","date":"January 5, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/install_vmtools_in_arch_seris_os/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"manjaro","url":"/tags/manjaro/"},{"title":"vm_ware","url":"/tags/vm_ware/"}],"timestamp":1641388533,"title":"Arch/Manjaro Linux安装vmware Tools"},{"authors":[],"categories":[],"content":"说明\rSEGGER RTT调试全名为SEGGER’s Real Time Transfer，实时传输调试，其调试传输能力非常优秀，表现为调试的数据传输速度快、时延低。并且通过相应的API，可以将其配置为多个窗口调试。\n优缺点\r优点\r最显而易见的一个优点就是使用SEGGER RTT进行数据调试，可以节省使用串口的资源进行显示输入输出，从而达到节省IO管脚资源的效果。\n以下为SEGGER官方给出的性能数据\nSEGGER 传输82 Bytes数据时延\r由上图可知，SEGGER的其中一个优点就是数据传输的速度快、时延低。由于直接使用调试管脚进行数据传输，速度能够比串口快上不少，并且传输时延非常低，可以用来调试实时数据。\n缺点\rSEGGER RTT调试的唯一缺点估计就是必须要使用SEGGER退出的JLink进行调试了，不过在一些大神的带动下，一些其他的工具也能够使用SEGGER的RTT调试接口进行调试，所以问题不大。\n如何使用\r集成至项目中\r可以直接点击这里进行下载相关文件。\n下载后能够看到这些文件：\nSEGGER RTT相关文件\r然后将文件添加至工程目录中并在工程配置好文件包含路径即可。\n代码中简单使用\r此步骤的目的只是简单的使用RTT调试来代替串口输出，请确保使用的是JLink调试器，因为不配置buffer。\n初始化 1 SEGGER_RTT_Init(); 2 SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP); 打印数据 可以像使用printf一样来使用这个打印函数，如下：\n1 SEGGER_RTT_printf(0, \u0026#34;this is rtt print0 , id = %d\\r\\n\u0026#34;, i); 现象 指定调试的输出终端窗口\r因为需要指定其他的终端，所以不能像上面一样直接简单初始化就使用，因为上面的操作之所以这么简单是因为JLink调试器能够默认给SEGGER RTT提供一个默认的缓冲区到终端0，所以可以在简单配置后能够有一个能用的终端。\n但是很明显，如果使用多终端的输出并且指定print的输出终端的话，就需要自己来初始化一个缓冲区buffer了。\n初始化缓冲区 1 uint8_t RTT_Buffer[256]; 初始化RTT 1 SEGGER_RTT_Init(); 2 SEGGER_RTT_ConfigUpBuffer(0, NULL, RTT_Buffer, 256, SEGGER_RTT_MODE_NO_BLOCK_SKIP); 指定窗口打印 1 SEGGER_RTT_SetTerminal(1); //配置为终端1，默认为终端0，可配置为从1-F共16个终端 2 SEGGER_RTT_printf(0, \u0026#34;this is rtt print0 , id = %d\\r\\n\u0026#34;, test_value); 现象 指定终端输出信息\r该功能不能像打印那样可以格式化字符串，仅能输出普通字符串，但是加以增加字符串操作也能达到打印的效果\n初始化步骤和打印普通数据一样\n输出处理的字符串 1 SEGGER_RTT_TerminalOut(0, \u0026#34;SEGGER RTT start\\r\\n\u0026#34;); 2 3 // ... 4 5 sprintf(term_str, \u0026#34;this is rtt print2\\r\\ndata is send in %d times\\r\\n\u0026#34;, i); 6 ret = SEGGER_RTT_TerminalOut(2, term_str); SEGGER_RTT_TerminalOut函数的第一个参数为终端号\n现象 总结\rRTT调试是一种在研发阶段的很好的调试手段，相对于串口来说无疑是节省了很多硬件资源，但是在产品阶段并不方便接出相应的RTT调试管脚，所以RTT的使用还是应该按需来进行。\nimpressionyang","date":"January 5, 2022","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/rtt_view_experiment/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"rtt_view","url":"/tags/rtt_view/"},{"title":"debug","url":"/tags/debug/"}],"timestamp":1641387768,"title":"关于SEGGER RTT调试"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"用途\rYour smartphone is a mobile lab.\n如上所说，这个软件就是你的智能手机上的移动实验室。\n该app是将手机上的传感器应用起来用于进行测量等功能的软件，它可以使用我们手机上的传感器进行数据采集，然后通过算法将结果以可视化的方式呈现出来。\n项目地址\r项目官网首页地址（点击）\n项目源代码地址（点击）\n下载地址\r下载地址在项目官网首页的下载页面（点击）\nimpressionyang","date":"January 4, 2022","img":"https://img.impressionyang.top/2022/01/04/phyphox_icon.png","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/good_apps_of_phyphox/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"app","url":"/tags/app/"},{"title":"phyphox","url":"/tags/phyphox/"}],"timestamp":1641227529,"title":"好物推荐 Phyphox --一个强大的工具集"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r以windows为主、linux使用WSL子系统的路子走不通了，相关帖子在这里。因为使用WSL方案USB串口无法直通到linux方案中，并且GUI方面也是有所缺失，使用起来并不得劲。所以打算转换思路，以linux为主、windows为辅的路子（linux下使用虚拟机运行windows）。所以在笔记本上重新捡起manjaro KDE`，感觉触控板要用起来，所以有了本篇帖子\n安装相关程序\r一来咱啥也不管，和输入设备和手势相关的工具全装上\n1sudo pacman -S libinput xf86-input-libinput libinput-gestures wmctrl xdotool 其实其中关键的就是libinput-gestures，他的官方文档在这里，里面有详细的关于该工具的介绍，本文只是简单的讲解如何使用而已\n配置\r根据一下步骤一步步进行即可开始使用手势操作了\n1. 添加自己进入input用户组\r1sudo gpasswd -a $USER input 2. 配置相应的手势操作\r关于手势操作的配置，该工具都是保存在配置文件中的，所以根据以下步骤创建属于自己用户的配置文件\n创建当前用户的配置文件 1touch ~/.config/libinput-gestures.conf 在其中添加相应的配置 下面是支持的手势操作在文档中查找即可，配置文件内容为所有你想要的动作集合，每个动作的配置格式如下：\n1gesture swipe 方向 手指个数 xdotool key 按键组合 下面是我的配置\n1gesture swipe right 4 xdotool key ctrl+F1 2gesture swipe left 4 xdotool key ctrl+F2 3gesture swipe down 4 xdotool key ctrl+F9 4gesture swipe up 4 xdotool key ctrl+F8 5gesture swipe up 3 xdotool key ctrl+F9 6gesture swipe down 3 xdotool key super+d 7gesture swipe right 3 xdotool key alt+Right 8gesture swipe left 3 xdotool key alt+Left 9gesture pinch in 2 xdotool key ctrl+minus 10gesture pinch out 2 xdotool key ctrl+plus 注意：上面的按键组合是实际会触发的按键操作，所以需要确认自己的系统设置会有对应的快捷键配置哦\n启动工具并配置自启动 1libinput-gestures-setup start autostart 3. 享受你的成果\r好了，到此基本上手势操作应该是可以正常运行了，根据自己的需要去配置相应的操作就行。\n总结\r基本上就是一个libinput-gestures的使用而已，应该不会造成太大的问题，如果有问题还请留言。\nimpressionyang","date":"December 26, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/kde_gesture/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"touchpad","url":"/tags/touchpad/"},{"title":"KDE","url":"/tags/kde/"},{"title":"Linux","url":"/tags/linux/"},{"title":"manjaro","url":"/tags/manjaro/"}],"timestamp":1640534097,"title":"KDE桌面下的触控板手势"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r为什么要使用VNC： VNC是一个通用的桌面分享协议，与windows的RDP协议齐名，用于在不同电脑键进行桌面分享，可以在另一台电脑操控你当前的电脑。当前我的需求就是在windows系统下链接我的linux主机进行远程操作\n为什么使用realvnc：因为realvnc是我唯一使用成功的vnc工具，tigervnc一直不能进行启动，很令人心烦，当然，未来也会继续尝试折腾tigervnc的，因为这才是开源正统。\n本次是在manjaro linux下进行安vncserver、在windows下安装vncviewer。 安装\r使用命令行安装：\n1yay -S realvnc-vnc-server 官方提供的是deb的安装报，arch系列的话还是使用aur进行安装吧。 配置桌面启动\r使用vnc的话，一般是使用用户登陆动作触发一个桌面session的启动，一般来只要在相关地方配置对应的桌面启动命令即可，使用realvnc的话使用的是xstartup脚本进行配置的。\n一般使用的桌面session启动命令都可以通过使用命令补全功能猜出来，操作方式为：在控制台中输入start，然后通过tab按键进行补全操作，就可以看到差不多是桌面启动的命令了，如下图：\n知道使用什么命令来进行启动桌面之后，就可以开始着手进行配置vncserver了\n一般使用的启动vncserver的话都是使用默认启动命令进行的，而默认命令使用的xstart脚本可以从启动的命令中看到，如下\n一般的桌面默认配置下连接是不能正常查询到当前的桌面session的，表现出来的状况为启动后通过vncviewer连接后只显示一个终端窗口，所以这时就需要去配置启动脚本了，当然，如果能够正常连接的话也不需要进行配置，所以配置前先启动连接试试\n我安装的vncserver提示是使用/etc/vnc/xstartup这个启动文件，所以需要配置这个文件即可；配置这个文件中的twm为自己需要的桌面session启动命令，如下：\n1elif which twm \u0026gt; /dev/null 2\u0026gt;\u0026amp;1; then 2 $XTERM_COMMAND \u0026amp; 3 SESSIONBIN=\u0026#34;startplasma-x11\u0026#34; 4fi 启动和关闭vncserver\r启动命令：\r1vncserver -geometry 1920x1080 -alwaysshared -depth 24 -dpi 1 :1 命令的参数如下：\ngeometry： 分辨率设置，后面跟着分辨率设置参数：1920x1080 alwaysshared：配置为一直可以连接 depth： 配置色彩深度 dpi：配置dpi,我这里的命令应该存在问题，但是我设置太高了的话视频传输会卡 :1: 启动的桌面，：1就是桌面1，对应的端口为5901;：2就是桌面2，对应端口为5902;以此类推 关闭命令：\r1vncserver -kill :1 命令的参数如下：\nkill： 关闭一个桌面，后面跟着桌面的参数， ：1就是对应屏幕1，也是以此类推 vncviewer连接\r直接连接地址： x.x.x.x:1即可，x换为你对应的ip地址\n总结\r好了，经过这一番折腾，VNC server应该是能够用起来了，说明一下，默认下realvnc是需要购买密钥授权激活才能运行的，不然会提示没有授权无法启动，我这里就不说明其他的渠道来激活使用了，你们自己各凭本事。\n","date":"November 14, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/real_vnc_config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"vnc","url":"/tags/vnc/"}],"timestamp":1636891322,"title":"Realvnc使用小结"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"说明\r此贴说明对该主题做出的更改点，主要是为了达成原有hexo站点功能\n更改\r主要更改点\n添加置顶功能，在front matter中添加top即可置顶文章 添加shortcode : stempowered游戏分享功能，在个人相关下拉中 上述的shotcode更改中，添加了ratio 4x1的配置，因为游戏内容页面大致为4:1 后续有更改继续更新\n修改了katex，使用mathjax作为公式渲染 impressionyang","date":"May 16, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/hugo_theme_bootstrap_change/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"hugo","url":"/tags/hugo/"}],"timestamp":1621147188,"title":"对于此hugo主题的更改"},{"authors":[],"categories":[],"content":"steam游戏分享\r在评论区分享一下你们喜欢的游戏吧\nimpressionyang\r","date":"May 16, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/about/games/","series":[],"smallImg":"","tags":[],"timestamp":1621144418,"title":"Steam游戏分享"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"说明\r本贴说明为何更改使用hugo作为静态博客生成器\nhugo是什么\rHugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n上面引用的hugo官网的文字已经说明了该工具是一个非常快速的静态博客生成器了.\nhugo的优点和缺点\r优点 由于使用go语言编写,使得hugo是一个天生运行快速的工具,在与其他静态博客生成器对比是显得有很大的优势.\n缺点 由于国内的用户比较少,所以对应的文档和主题/插件都比较缺失\n为什么选择hugo\r在此之前,我使用的是国内知名度比较高的hexo作为我的博客生成器,得益于大量的用户基数,hexo有着完备的文档支持和主题插件支持,使用hexo我能够轻易的获得各种我需要的网页表现效果以及各种方便的插件来达成我对于博客上面的一些要求.\n但是,在使用hexo的过程中,有一个问题一直给我带来很大的困扰,那就是在写完一篇帖子之后,生成网页的耗时着实有点惊人,并且由于使用很多的node_mudoles,使得生成过程中很容易因为一些问题导致生成失败.\n所以,我寻找一种生成快速的,文件依赖小的博客生成器. 于是,我遇到了hugo\n为什么用了utterance\r关于为什么使用了utterance而不是使用valine，原因是我不想在被路人评论了，写博客主要目的不是为了博得瞩目，所以留下评论接口仅仅是为了能够为一些人的技术疑惑帮上忙（如果我太菜了帮不上另说QAQ）\n后记\r以上就是我为什么选择了hugo作为未来的博客站生成器了, 顺带说一下,并不是特别想写关于hugo的博客搭建文档,因为使用hugo作为博客生成器的话每个主题的搭建都有可能有所不同,所以推荐新手入门还是用hexo这种文档支持齐全的工具吧,有了基础以及需求之后在谋求hugo的使用方法,到那时你肯定就能够知道如何搭建hugo的运行环境了.\nimpressionyang","date":"May 16, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/about_change_to_hugo/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"talk","url":"/tags/talk/"},{"title":"hugo","url":"/tags/hugo/"},{"title":"dialy","url":"/tags/dialy/"}],"timestamp":1621095033,"title":"关于换到hugo"},{"authors":[],"categories":[{"title":"book","url":"/categories/book/"}],"content":"说明\r读书分享的说明\n读书分享一般用来分享一些书籍的读后感的,估计是会长期的鸽下去的2333\n","date":"May 15, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/book/book_about/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"book","url":"/tags/book/"},{"title":"dialy","url":"/tags/dialy/"},{"title":"notes","url":"/tags/notes/"}],"timestamp":1621036800,"title":"关于读书分享"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"说明\r此脚本用于更新git仓库，主要用于使用ssh克隆的仓库，使用https克隆或者直接下载的不可使用此脚本进行更新，编写此贴用于保存脚本以供后用\nLinux平台\rLinux平台下的脚本使用的是bash shell脚本进行编写的\n1#! /bin/bash 2######################################## 3#Usage: ./update comment \u0026#34;msg\u0026#34; 4######################################## 5echo start update! 6 7DATE=`date` 8 9git add . 10git commit -m \u0026#34;$0 : $1 $DATE\u0026#34; 11git push origin master 12######################################## 13# written by impressionyang # 14######################################## 使用./update \u0026quot;msg\u0026quot;进行更新仓库\nWindows平台\rWindows平台下使用bat脚本进行更新仓库\n1:::::::::::::::::::::::::::::::::::::::::::: 2:: Usage: ./update.bat \u0026#34;msg\u0026#34; :: 3:::::::::::::::::::::::::::::::::::::::::::: 4@echo off 5setlocal enabledelayedexpansion 6@echo \u0026#34;start update!\u0026#34; 7 8:: 下方设置参数 9@set DATE=\u0026#34;%date% %time%\u0026#34; 10@set FILE=\u0026#34;%0\u0026#34; 11@set MSG=\u0026#34;%1\u0026#34; 12 13:: 下方将双引号删除 14@set FILE=%FILE:\u0026#34;=% 15@set MSG=%MSG:\u0026#34;=% 16@set DATE=%DATE:\u0026#34;=% 17 18:: 下方更新git 19@git add . 20@git commit -m \u0026#34;%FILE% : %MSG% %DATE%\u0026#34; 21@git push origin master 22:::::::::::::::::::::::::::::::::::::::::::: 23:: written by impressionyang :: 24:::::::::::::::::::::::::::::::::::::::::::: 使用./update.bat \u0026quot;msg\u0026quot;进行更新仓库\nimpressionyang","date":"May 3, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/git-update-script/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"git","url":"/tags/git/"},{"title":"script","url":"/tags/script/"}],"timestamp":1620005324,"title":"Git更新脚本"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"说明\r该帖子是用来保存Qt的相关配置的，比如代码片段、快捷键等，用来进行新开发环境搭建时的参考\n配置\r代码片段\r代码片段是使用相关的关键词进行触发的代码片段插入方法，在Qt中有一定的api支持，一般用于进行函数注释和文件头部注释等\n文件头部注释 该片段注释一般用于新文件的项目、创建日期、文件名及文件说明等， 配置以及效果如下\n文件头部注释配置\n1/***************************************************** 2 * @Project: %{CurrentProject:Name} 3 * 4 * @File: %{CurrentDocument:FileName} 5 * 6 * @Description: 7 * 8 * @Author: impressionyang 9 * 10 * Created on %{CurrentDate:yyyy-MM-dd} 11 * 12 * Copyright (c) %{CurrentDate:yyyy} yangxy All rights reserved. 13 *****************************************************/ 内容中的%{CurrentProject:Name}等即为Qt中内置的代码片段的接口，其功能与英文名意思一致\n效果如下：\n文件头部注释的效果\n函数注释 函数注释一般用于指示函数功能，参数用意以及返回内容等\n函数注释配置\n配置内容为：\n1/***************************************************** 2 * @Function Name: 3 * 4 * @brief 5 * 6 * @param 7 * 8 * @return 9 *****************************************************/ 使用效果如下\n函数注释效果\n快捷键\r快捷键一般用于一些功能的的直接触发，此次仅配置了代码格式化的功能\nclang格式化快捷键配置（与vscode配置一致）\n补充：使用clang配置需要打开Qt Creator的插件beautifier(如下图), 然后才能在配置中添加clang的配置，需要添clang-formate的可执行文件（在vscode中提取，vscode安装插件C/C++即会自动安装）\n安装beautifier\n配置beautifier\n附.clangformat文件内容\n1--- 2Language: Cpp 3# BasedOnStyle: WebKit 4AccessModifierOffset: -2 5AlignAfterOpenBracket: Align 6AlignConsecutiveMacros: true 7AlignConsecutiveAssignments: true 8AlignConsecutiveBitFields: true 9AlignConsecutiveDeclarations: true 10AlignEscapedNewlines: Right 11AlignOperands: AlignAfterOperator 12AlignTrailingComments: true 13AllowAllArgumentsOnNextLine: true 14AllowAllConstructorInitializersOnNextLine: true 15AllowAllParametersOfDeclarationOnNextLine: true 16AllowShortEnumsOnASingleLine: true 17AllowShortBlocksOnASingleLine: Empty 18AllowShortCaseLabelsOnASingleLine: false 19AllowShortFunctionsOnASingleLine: All 20AllowShortLambdasOnASingleLine: All 21AllowShortIfStatementsOnASingleLine: Never 22AllowShortLoopsOnASingleLine: false 23AlwaysBreakAfterDefinitionReturnType: None 24AlwaysBreakAfterReturnType: None 25AlwaysBreakBeforeMultilineStrings: false 26AlwaysBreakTemplateDeclarations: MultiLine 27BinPackArguments: true 28BinPackParameters: true 29BraceWrapping: 30 AfterCaseLabel: true 31 AfterClass: true 32 AfterControlStatement: Never 33 AfterEnum: true 34 AfterFunction: true 35 AfterNamespace: true 36 AfterObjCDeclaration: false 37 AfterStruct: true 38 AfterUnion: true 39 AfterExternBlock: true 40 BeforeCatch: false 41 BeforeElse: false 42 BeforeLambdaBody: false 43 BeforeWhile: false 44 IndentBraces: false 45 SplitEmptyFunction: true 46 SplitEmptyRecord: true 47 SplitEmptyNamespace: true 48BreakBeforeBinaryOperators: All 49BreakBeforeBraces: Custom 50BreakBeforeInheritanceComma: false 51BreakInheritanceList: BeforeColon 52BreakBeforeTernaryOperators: true 53BreakConstructorInitializersBeforeComma: false 54BreakConstructorInitializers: BeforeComma 55BreakAfterJavaFieldAnnotations: false 56BreakStringLiterals: true 57ColumnLimit: 130 58CommentPragmas: \u0026#39;^ IWYU pragma:\u0026#39; 59CompactNamespaces: false 60ConstructorInitializerAllOnOneLineOrOnePerLine: false 61ConstructorInitializerIndentWidth: 2 62ContinuationIndentWidth: 2 63Cpp11BracedListStyle: false 64DeriveLineEnding: true 65DerivePointerAlignment: false 66DisableFormat: false 67ExperimentalAutoDetectBinPacking: false 68FixNamespaceComments: false 69ForEachMacros: 70 - foreach 71 - Q_FOREACH 72 - BOOST_FOREACH 73IncludeBlocks: Preserve 74IncludeCategories: 75 - Regex: \u0026#39;^\u0026#34;(llvm|llvm-c|clang|clang-c)/\u0026#39; 76 Priority: 2 77 SortPriority: 0 78 - Regex: \u0026#39;^(\u0026lt;|\u0026#34;(gtest|gmock|isl|json)/)\u0026#39; 79 Priority: 3 80 SortPriority: 0 81 - Regex: \u0026#39;.*\u0026#39; 82 Priority: 1 83 SortPriority: 0 84IncludeIsMainRegex: \u0026#39;(Test)?$\u0026#39; 85IncludeIsMainSourceRegex: \u0026#39;\u0026#39; 86IndentCaseLabels: false 87IndentCaseBlocks: false 88IndentGotoLabels: true 89IndentPPDirectives: None 90IndentExternBlock: AfterExternBlock 91IndentWidth: 2 92IndentWrappedFunctionNames: false 93InsertTrailingCommas: None 94JavaScriptQuotes: Leave 95JavaScriptWrapImports: true 96KeepEmptyLinesAtTheStartOfBlocks: true 97MacroBlockBegin: \u0026#39;\u0026#39; 98MacroBlockEnd: \u0026#39;\u0026#39; 99MaxEmptyLinesToKeep: 1 100NamespaceIndentation: Inner 101ObjCBinPackProtocolList: Auto 102ObjCBlockIndentWidth: 2 103ObjCBreakBeforeNestedBlockParam: true 104ObjCSpaceAfterProperty: true 105ObjCSpaceBeforeProtocolList: true 106PenaltyBreakAssignment: 2 107PenaltyBreakBeforeFirstCallParameter: 19 108PenaltyBreakComment: 300 109PenaltyBreakFirstLessLess: 120 110PenaltyBreakString: 1000 111PenaltyBreakTemplateDeclaration: 10 112PenaltyExcessCharacter: 1000000 113PenaltyReturnTypeOnItsOwnLine: 60 114PointerAlignment: Left 115ReflowComments: true 116SortIncludes: false 117SortUsingDeclarations: true 118SpaceAfterCStyleCast: false 119SpaceAfterLogicalNot: false 120SpaceAfterTemplateKeyword: true 121SpaceBeforeAssignmentOperators: true 122SpaceBeforeCpp11BracedList: true 123SpaceBeforeCtorInitializerColon: true 124SpaceBeforeInheritanceColon: true 125SpaceBeforeParens: ControlStatements 126SpaceBeforeRangeBasedForLoopColon: true 127SpaceInEmptyBlock: true 128SpaceInEmptyParentheses: false 129SpacesBeforeTrailingComments: 1 130SpacesInAngles: false 131SpacesInConditionalStatement: false 132SpacesInContainerLiterals: true 133SpacesInCStyleCastParentheses: false 134SpacesInParentheses: false 135SpacesInSquareBrackets: false 136SpaceBeforeSquareBrackets: false 137Standard: Latest 138StatementMacros: 139 - Q_UNUSED 140 - QT_REQUIRE_VERSION 141TabWidth: 8 142UseCRLF: false 143UseTab: Never 144WhitespaceSensitiveMacros: 145 - STRINGIZE 146 - PP_STRINGIZE 147 - BOOST_PP_STRINGIZE 148... 字体\r在Qtcreator中也会安装我钟意的编程字体JetBrains Mono字体，下载后安装至系统中即可使用\n字体配置\nimpressionyang","date":"May 2, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/qt-creator-my-setup/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Qt","url":"/tags/qt/"}],"timestamp":1619999704,"title":"Qt个人配置"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r本文也是在Win10主机下配置轻量级开发环境的一个帖子，主要是用来记录Win10下的新Windows Terminal的安装和配置，留作以后参考\n安装\r直接在Win10商店中安装Windows Terminal即可\n配置\rWindows Terminal的配置基本上是直接配置它的配置文件进行的，该文件通过它的配置按钮调出，有系统默认的json文本编辑器进行编辑\n字体\r字体的配置需要在profile节点中的default进行编辑 JetBrains Mono字体\rJetBrians Mono字体是由JetBrains公司开发的一款开源等宽字体，它旗下的产品在业内的知名度人尽皆知，所以这款字体也是和它的老大哥CLion等一样是很硬的存在，非常推荐使用该字体\n配置\r配置如下 1\u0026#34;defaults\u0026#34;: 2{ 3 // Put settings here that you want to apply to all profiles. 4 \u0026#34;cursorHeight\u0026#34; : 25, 5 \u0026#34;fontFace\u0026#34; : \u0026#34;JetBrains Mono\u0026#34;, 6 \u0026#34;fontSize\u0026#34; : 14 7} 背景颜色和光标\r这些配置也是在profile节点中的default进行编辑\n1\u0026#34;defaults\u0026#34;: 2{ 3 // Put settings here that you want to apply to all profiles. 4 \u0026#34;cursorHeight\u0026#34; : 25, 5 \u0026#34;fontFace\u0026#34; : \u0026#34;JetBrains Mono\u0026#34;, 6 \u0026#34;fontSize\u0026#34; : 14, 7 \u0026#34;cursorShape\u0026#34; : \u0026#34;vintage\u0026#34;, 8 \u0026#34;colorScheme\u0026#34; : \u0026#34;Solarized Dark\u0026#34;, 9 \u0026#34;acrylicOpacity\u0026#34; : 0.5, 10 \u0026#34;useAcrylic\u0026#34; : true 11}, 未完待续，有更新再追加 impressionyang","date":"February 17, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/win10-windows-terminal-setup/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"win10","url":"/tags/win10/"}],"timestamp":1613528574,"title":"Win10安装配置Windows Terminal"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r安装WSL2 Linux子系统是我打算在游戏主机上面安装轻量级开发环境的下一步打算，至于为什么不用更好评的WSL1我也不多说，毕竟WSL2是Microsoft主推的，支持的特性和后续的维护应该会更快且优先级更高，所以本文使用WSL2\n系统需求\r下面只是列举基本要求，详细的内容请查看微软的文档传送门\n所以如果不是win10的话就基本不能体验WSL2了\n环境配置\r根据上文需求，一般需要开启WSL功能和安装.NetFramework了\nWSL功能\r依次从控制面板中进入程序-\u0026gt;启用或关闭Windows功能中打开下面红色区域内容\n.NetFramework\r如果在上一小结启用功能后未能正常安装WSL的话可以手动安装，安装包下载链接传送门\nWSL2 Linux内核更新包\rWSL2还需要安装相关的内核更新包，下载地址如下\nhttps://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\n启用WSL和WSL2\r以下命令需要在有管理员权限的power shell中运行，并且需要完成以上小结内容\n启用适用于 Linux 的 Windows 子系统 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机功能 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 将 WSL 2 设置为默认版本 1wsl --set-default-version 2 导出和导入\rWSL的镜像格式为.vhdx格式\n导出\r在power shell中使用以下命令来导出已经安装的WSL镜像（安装WSL发行版可在微软商店中进行安装）\n1wsl --export \u0026lt;distrio\u0026gt; filename.tar 替换为你的发行版 filename.tar可包含文件路径，可以指定到某一磁盘中 导入\r1wsl --import \u0026lt;distrio\u0026gt; directory filename.tar 替换为你导出的发行版 directory为解压出的文件夹位置，可用于转移WSL镜像的存储路径 filename.tar可包含文件路径 后记\r可以在VSCode中安装Remote WSL插件来访问导入的WSL镜像，或者使用Windows Terminal来访问镜像\nRemote WSL\rWindows Terminal\rimpressionyang","date":"February 15, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/win10-install-wsl2/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"win10","url":"/tags/win10/"}],"timestamp":1613423870,"title":"Win10重新安装导出的WSL2镜像"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r为什么想要安装scoop并且是在win10中呢？这个问题主要聚焦于我的游戏小主机上，我想要能够随时玩游戏的同时也能够进一定的博客工作或者轻量级的开发（现在wsl2中），所以需要使用scoop这个Windows的命令行工具。 但是这个工具在国内进行安装是有一定的难度的，主要是网络环境以及系统的需求，所以做此帖子留作参考\n系统需求\r操作系统： win10 （主要是基本能够一步到位，不用考虑以下因素，当然，Windows的其他发行版满足以下需求也可以进行安装） power shell版本： 3.0以上 网络需求\r能够正常访问GitHub的raw文件地址，如果访问不了一般报以下错误（无法访问GitHub的raw文件地址）\n或者以下错误（官网的文件也获取不到）\n安装\r安装一般有三部：配置运行环境、安装scoop、测试scoop\n配置运行环境\r一般需要是的power shell处于可远程执行的状态，所以需要切换运行策略(ExecutionPolicy)\n1Set-ExecutionPolicy RemoteSigned -scope CurrentUser 如果有确认的话无脑确认Y（yes）就可以了\n安装scoop\r鉴于我这里也是不能正常访问GitHub的raw文件，没有改host也没有科学上网，所以使用的是国内gitee中转的方式，由作者RubyKids\n上传的，也可以使用他的安装方式。\n运行命令如下\n1iex (new-object net.webclient).downloadstring(\u0026#39;https://gitee.com/RubyKids/scoop-cn/raw/master/install.ps1\u0026#39;) 测试scoop\r使用help命令来测试scoop的安装状态\n1scoop help 能够出现以下打印即可证明scoop安装成功\nimpressionyang","date":"February 15, 2021","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/win10-install-scoop/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"win10","url":"/tags/win10/"}],"timestamp":1613419854,"title":"Win10 安装scoop的正确姿势"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"先导\r本文用于在qt中使用配置文件进行一些配置的保存\n方法\r关键点就是使用qt的一个类QSettings，该类提供一系列接口用于配置文件的操作如读取和写入，支持的配置文件格式有ini、conf等。使用该类在软件启动时进行初始化操作对一些软件的配置进行赋值操作，可以使得上一次保存的配置可以继续使用，增加程序使用的便捷性。\n实现\r定义\r1QSettings setting = new QSettings(file_path, QSettings::IniFormat); 读取\r1QVaraint value = setting-\u0026gt;value(\u0026#34;key/item\u0026#34;); 讲解\nkey是指配置的组的键值 item是指这个配置组里面的具体的配置项的键值 返回的是一个QVarant类型的值，可以通过对应的to方法转换为对应的数据，如字符串用toString 如果没有这个配置的话则返回空的QVarant 写入\r1setting-\u0026gt;setValue(\u0026#34;key/item\u0026#34;, value); 讲解\nkey和item同上，是用来定位配置项目的。 value则是写入进配置文件的对应配置项的值，类型是QVarant，直接写入值可以自动转换类型 一些错误\r中文乱码\r中文乱码是因为没有对配置文件的编码做配置而于系统使用编码不匹配导致的，基本解决方案是将配置文件使用一个比较统一的编码格式，因为我个人会跨平台使用代码，所以我会把配置文件的编码统一保存为utf-8的格式。然后使用方法setIniCodec(QTextCodec::codecForName(\u0026quot;UTF-8\u0026quot;));来设置编码格式。\n注意：使用该方法需要包含头文件#include \u0026lt;QTextCodec\u0026gt;，否则无法使用QTextCodec的静态方法，并且注意配置文件的编码格式和设置的编码格式匹配。 impressionyang","date":"December 29, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/qt-qsettins-uage/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"Qt","url":"/tags/qt/"},{"title":"skill","url":"/tags/skill/"},{"title":"QSetting","url":"/tags/qsetting/"}],"timestamp":1609284857,"title":"Qt使用配置文件"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r为什么不用minicom呢？功能又强大由好用不是。主要原因就是minicom没有彩色文字，看着难受，特别是调试ARM Linux的时候233\n安装\r因为正常是在Debian系列的Linux发行版上面使用的(deepin或者ubuntu这些的，解决方案比较完善)，所以就是用apt来进行安装，其他发行版使用自己的包管理软件进行安装\n1sudo apt install picocom -y 连接调试设备\r连接前准备\r首先要确定是接入的设备\n1dmesg | grep ttyUSB 然后使得这个设备能被picocom工具访问使用\n1sudo chmod 777 /dev/ttyUSBx 请自行将ttyUSBx替换为当前使用的串口设备\n连接串口设备\r下面是一般连接一个串口设备说使用的命令\n1picocom -b 115200 /dev/ttyUSBx 参数讲解\n-b: 设置波特率参数 /dev/ttyUSBx:串口设备，请替换为当前使用的串口设备 打开帮助提示页面\r按动Ctrl a+h就可以弹出帮助页面，里面有相关的命令提示可以做什么，需要注意的一点是，里面的命令提示都是说C-x什么的，其实C-就是由Ctrl+a转义过来的，正如帮助页面的C-h，就是用Ctrl a+h打开的，所以其他的命令也是同理\n发送接收文件\r如果直接使用上面的连接串口设备的命令直接去进行文件发送的话，你就会发现Ctrl a+s进行发送的时候根本没办法确定使用哪种协议进行的，很让人摸不着头脑(其实默认的传输发送接收模式之前的连接截图已经有曝光了，就是z模式233)，其实只要仔细点去阅读picocom的man文档的话就能够看到相关的发送接收小节里面有提及相关的内容\n所以，确定好想使用何种方式进行传输之后就可以使用相应的命令去打开picocom了\n例如使用ymode进行发送接收的例子\n1picocom --send-cmd \u0026#34;sb -vv\u0026#34; --receive-cmd \u0026#34;rb -vv\u0026#34; -b 115200 /dev/ttyUSBx 同样的，使用当前的串口设备文件\n退出picocom\r直接就是按动Ctrl a+q就可以\n尾声\rpicocom相较于minicom功能性来说，还是有那么一点欠缺的，但是picocom毕竟颜值高呀，在这个看脸的时代，picocom难道不是最佳选择吗233[手动狗头]\nimpressionyang","date":"September 17, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/picocom-dialy-use/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"picocom","url":"/tags/picocom/"}],"timestamp":1600348027,"title":"使用picocm来进行Linux下的串口调试"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r本文是为了记录在编程中进行一些在文件夹中查找某些关键字进行配置时查找文件过于麻烦的解决办法\n在Linux开发中使用一些命令或者命令的配合进行查找文件内容及匹配关键词还是比较方便的。\n使用grep\rgrep是在使用Linux时经常会用到的一个命令了，这个命令平时大都主要用来进行对一段输出的关键字定位，但是这个命令也可以通过使用某些参数来达到文件夹文件内容遍历的效果\n命令原型\r1grep -nr \u0026#34;str\u0026#34; path 参数说明\rgrep: 就是grep命令 -nr: n是line number行号，r是recursive，可以理解为遍历文件文件夹 \u0026ldquo;str\u0026rdquo;: 双引号里面的str就是要查找的内容，用双引号何以使用空格和一些字符进行查找 path: path就是查找路径，默认是./，也就是当前目录开始，也可以手动指定目录 实例\r1grep -nr \u0026#34;/bin/bash\u0026#34; /home/$USER 优缺点\r优点：命令简单方便，简短 缺点：会遍历所有文件，效率较低 使用find、xargs和grep配合\rfind是查找指令，用来查找文件的；xargs可以将标准输入作为另一个命令的参数；grep上面已经解释过了。那么，如果使用find来循环查找文件，使用他输出的文件名作为参数给xargs，xargs再将文件名作为grep的参数输入，使用grep来查找文件内容进行定位不久可以实现文件内容查找了吗\n命令原型\r1find path -name \u0026#34;PATTEN\u0026#34; | xargs grep -n \u0026#34;str\u0026#34; | grep \u0026#34;str\u0026#34; 参数说明\rfind、xargs、grep：上面已经讲过，分别是三个软件 name：就是通过名字查找，后面跟着的参数可以通过正则表达式类似的方法限定文件名 其他grep或者类似的参数据不赘述了 实例\r1find /home/$USER/.config -name \u0026#34;*.sh\u0026#34; | xargs grep \u0026#34;/bin/bash\u0026#34; | grep \u0026#34;/bin/bash\u0026#34; 优缺点\r优点：可以通过-name来限定文件名，从而减少grep查看文件内容的次数，提高效率 缺点：命令冗长，难记 后记\r关于这两种方法的取舍其实还是看日常使用过程，如果文件夹内的文件较少，可以使用第一种方法，方便快捷；但是如果文件很多的情况下为了节省查找时间，可以使用第二种方法，能够较为快速地查找到想要的内容。\nimpressionyang","date":"August 22, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/search-content-in-files-of-dir/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"}],"timestamp":1598095132,"title":"Linux下在文件夹所有文件中查找相关内容"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":" 先导：写这篇文章是为了记录在Linux下常用的、简单的进行压缩文件的解压缩以及打包压缩文件的方法，以方便自己未来忘记了在查询\n全局说明\r下面的两个参数意义\ndest：目标文件，压缩的话将dest换成你想要的文件名 src：来源文件，是一个文件或者一个文件夹，压缩要想打包多个就空格后追加接下来的文件或者文件夹，解压的就不行了 tar.gz\r总的来说这是两种格式的压缩文件，tar是归档文件，gz是压缩文件，tar.gz是一种Linux下常用的压缩文件格式，一般的源代码包都是使用这种压缩文件的\n打包压缩\r将文件或者文件夹打包压缩成tar.gz\n1tar -czvf dest.tar.gz src 解压缩\r1tar -xzvf src.tar.gz 说明\r参数czxvf说明如下： -c: create,创建一个归档 -z: gzip、gunzip,gun的开放式压缩文档？ -x: extract,将文件从归档中提取出来 -v: verbose,详细的将文件列表信息打印出来 -f: file,从归档文件中操作 tar.bz2\r这个压缩文件格式和上一个差不多，也是先归档，然后才压缩一种压缩文件，不同的是压缩工具是bzip2。所以基本操作是一样的，只不过是压缩工具的参数换成-j就行了\n打包压缩\r1tar -cjvf dest.tar.bz2 src 解压缩\r1tar -xjvf src.tar.bz2 rar\r压缩打包\r1rar a dest.rar src 解压缩\r1unrar e src.rar 参数说明\ra: archive，添加文件至归档 e: extract, 将文件解压到当前位置 zip\r压缩打包\r1zip -r dest.rar src 解压缩\r1unzip -o src.rar 参数说明\rr: query，递归操作，子目录也打包 o: override, 覆盖解压缩 gzip\r压缩打包\r1gzip -c src \u0026gt;dest.gz 解压缩\r1gunzip -c src.gz \u0026gt;dest 参数说明\rc: 保留原文件 bzip2\r压缩打包\r1bzip2 -k src 运行后会在当前目录生成对应文件的压缩包，自动命名 解压缩\r1bzip2 -kd src.bz2 参数说明\rk: keep, 保留原文件 d: decompress, 解压缩 impressionyang","date":"August 11, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/compress-file-extract-and-compress/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"shell","url":"/tags/shell/"}],"timestamp":1597182631,"title":"Linux解压缩文件"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"先导\r因为在学习中使用到了二级指针进行操作，故而作此总结\n提前了解\r句柄\r以下词条来自百度百科 句柄（Handle）是一个是用来标识对象或者项目的标识符，可以用来描述窗体、文件等，值得注意的是句柄不能是常量 。\nWindows之所以要设立句柄，根本上源于内存管理机制的问题，即虚拟地址。简而言之数据的地址需要变动，变动以后就需要有人来记录、管理变动，因此系统用句柄来记载数据地址的变更。在程序设计中，句柄是一种特殊的智能指针，当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄 。\n二级指针\r指针是C语言中最高深莫测的部分了，能够直接操作内存的这些指针如果使用得当的话可以完成很多很高效的代码。而二级或者多级指针则能够达到你之前想都不敢想的效果。\n以下来自于百度百科 A(即B的地址)是指向指针的指针，称为二级指针，用于存放二级指针的变量称为二级指针变量．根据B的不同情况，二级指针又分为指向指针变量的指针和指向数组的指针。\n提出需求\r这次总结的内容则是将指针当做句柄放进函数当形参是动态地申请空间来用作其他用途的。\n首先，我们要知道，我们如果直接把指针变量的地址当做函数的实参，去在函数里面申请空间，由于形参定义是一级指针，是无法拿到动态申请的空间的，以下就是一个实例\n1#include \u0026lt;stdio.h\u0026gt; 2 3static void get_space(int* p) 4{ 5 p = (int *)malloc(sizeof(int)); 6 *p = 16; 7} 8 9int main() 10{ 11 int a = 10; 12 int* pa = \u0026amp;a; 13 printf(\u0026#34;*pa=%d \\t pa=%p \\n\u0026#34;, *pa, pa); 14 15 get_space(\u0026amp;pa); 16 printf(\u0026#34;*pa=%d \\t pa=%p \\n\u0026#34;, *pa, pa); 17 get_space(pa); 18 printf(\u0026#34;*pa=%d \\t pa=%p \\n\u0026#34;, *pa, pa); 19 return 0; 20} 运行得到以下结果\n显然，这个结果正和上面所说的，在main函数传进去的实参，无论是指针变量还是地址，在函数里面的操作并不能通过一级指针的形参返回动态申请的空间，这样做很容易出现野指针现象。\n原因其实很简单，在形参定义的一级指针变量只是有从实参传递过来的地址而已，无论是指针变量内的地址还是指针变量本身的地址，只是存在形参一级指针变量当中，正如上面表现的，不管指针变量p的内容是pa或者pa的地址，只要使用p去获取空间的地址，便会使得指针p的内容从pa或者pa的地址变成新空间的地址，而在main函数中的pa并没有被影响到。\n注意：上面的情况不要尝试用*p配合实参是pa的地址来接受新空间，会造成段错误，因为那样就是用一个int型的变量去接受一个int*型的值了\n那么，如果我想通过指针去在函数中获取动态的空间要如何操作\n解决方案\r其实通过上面的注意事项已经有一点眉目了，要想使用*符号来提取地址内容的方法来获得修改主函数传递的指针变量的内容权限的原理就是使得*p能够代表一个地址。由此可见，指针的指针那就是二级指针了，表现在代码中就是将上述的形参定义为二级指针并使用主函数的一级指针变量去传递参数。\n1#include \u0026lt;stdio.h\u0026gt; 2 3static void get_space(int** p) 4{ 5 *p = (int *)malloc(sizeof(int)); 6 int* temp = *p; 7 *temp = 66; 8} 9 10int main() 11{ 12 int a = 10; 13 int* pa = \u0026amp;a; 14 printf(\u0026#34;*pa=%d \\t pa=%p \\n\u0026#34;, *pa, pa); 15 16 get_space(\u0026amp;pa); 17 printf(\u0026#34;*pa=%d \\t pa=%p \\n\u0026#34;, *pa, pa); 18 return 0; 19} 运行得到以下结果：\n由此便能通过一个指针在函数中去动态申请空间并返回上一层中了。\n应用场景\r光是看上面的例子并不能了解这种方法的强大之处，但是模仿上面所说的句柄的思想，来举例说说这个方案的好处吧。\n首先假设，你负责一个项目的某个模块的编写，需要编写出测试app，模块实现以及该模块所需的协议，并且为了减少各个方法与模块之间的耦合性以及代码的简洁效率等因素不允许大量使用全局变量，但是你要完成这个模块有需要很多的变量来存储一些参数以供该模块实现内的各个方法进行调用，这时候要怎么解决呢？\n结构体是解决这种变量多的一种方案，但是如果在模块内使用全局变量的话你又如何管理这些空间呢（如果里面有较大的空间占用），只能等程序结束时清除吗\n这时候使用一个指针变量来保存一个动态空间的地址来进行操作显然更方便，也就是使用一个void*型指针变量来存储地址，在模块初始化时申请空间，模块进行功能时将地址下放，用完后动态地清理该空间。而这个void*型的指针就是本次提出的句柄的模仿。\n光是空口说出有点不太好说明该方案的可行性，下面用一个小例子来证明：\n假设下面的主函数函数和其他函数不在同一文件中 1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;stdlib.h\u0026gt; 3 4 5typedef struct couple_num 6{ 7 int a; 8 char b; 9} couple_num_t; 10 11void get_space(void** a) 12{ 13 printf(\u0026#34;*a addr:%p\\n\u0026#34;, *a); 14 *a = (couple_num_t *) malloc (sizeof(couple_num_t)); 15 printf(\u0026#34;%p\\n\u0026#34;, a); 16 couple_num_t *p = *a; 17 p-\u0026gt;a = 1000; 18 p-\u0026gt;b = \u0026#39;r\u0026#39;; 19} 20 21void show(void *a) 22{ 23 printf(\u0026#34;*a addr:%p\\n\u0026#34;, a); 24 couple_num_t* temp = a; 25 printf(\u0026#34;show:\\n%d\\n%c\\n\u0026#34;,temp-\u0026gt;a, temp-\u0026gt;b); 26} 27 28void release(void** a) 29{ 30 free(*a); 31} 32 33int main() 34{ 35 void *p = NULL; 36 37 printf(\u0026#34;origin p addr:%p\\n\u0026#34;, p); 38 39 get_space(\u0026amp;p); 40 printf(\u0026#34;after change p addr:%p\\n\u0026#34;, p); 41 42 couple_num_t* temp = p; 43 printf(\u0026#34;temp:%d\\n\u0026#34;,temp-\u0026gt;a); 44 45 show(p); 46 47 release(\u0026amp;p); 48 printf(\u0026#34;after release p addr：%p\\n\u0026#34;, p); 49 50 show(p); 51 52 getchar(); 53 54 return 0; 55} 运行结果如下：\n可以看到，使用这种方法，不用在主函数暴露结构体内容，也能够将结构体的地址空间进行掌握，高效的利用了指针的特性完成功能，使得各个方法之间相互影响减少，参数传递也简单，并且在使用完成后还能动态清除空间。\n后记\r这种方法在C语言下设计功能模块时特别有用，模仿了面向对象的句柄思想，减少模块间的耦合（不使用全局变量，各方法就不会无意间相互干扰了）。\nimpressionyang","date":"August 11, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/pointer-level2-as-handle/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"C","url":"/tags/c/"}],"timestamp":1597182465,"title":"C语言二级指针用法之模拟句柄用途"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r首先隔了这么久才继续进行更新的原因是网站备案和毕业设计，加上刚入职没有时间去进行内容更新，以后会继续更新了\n在pugjs中添加一些好用的东西这个系列会长期的添加更新，因为这些都是会用在博客当中的，而且这些操作都比较简单，都是在主题的相应文件位置添加相应代码即可。\n内容介绍\r这次添加的内容是在右边栏那里加上一个时钟，用来给阅读的人直观地看到时间，时钟的代码是直接从网上拷贝下来的，并且自己做了修改，地址是这里,打开这个链接就能看到一个时钟，此时检查页面元素定位到时钟所在的div标签，其中有一个canvas标签，将其复制下来，并且找到下面与之最近的script标签查看到时钟的逻辑代码，也将其复制下来进行修改后就差不多可以使用了。\n首先声明，代码是直接复制的，复制也没有删除，主要是为了学习用途，如果造成侵权或者修改了不应修改的地方，还请拿出版权证据证明后修改或者删除您的代码，自行复制后造成的一切问题与我无关\n脚本代码\r原脚本\r复制下来的脚本内容大致如下，内容有点多请别介意，方便复制 1\u0026lt;canvas id=\u0026#34;clock\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;400\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 2\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 3var time = new Date(); 4var h = time.getHours(); //时 5var m = time.getMinutes(); //分 6var s = time.getSeconds(); //秒 7h=h\u0026gt;12?(h-12)*5+parseInt(m/12):h*5+parseInt(m/12); //时针 初始位置 8//===================================== 9var x=200,y=200,sAngle=0; //x y 原点 秒针角度变量 10 11function draw(){ 12 var c=document.getElementById(\u0026#34;clock\u0026#34;); 13 var ctx=c.getContext(\u0026#34;2d\u0026#34;); //获取绘图对象 14 ctx.clearRect(0,0,c.width,c.height); //清除上次绘制的图形 15 s++;//秒针 16 17 ctx.fillStyle = \u0026#39;#fff\u0026#39; //填充白色背景色 18 ctx.fillRect(0,0,c.width,c.height); //设置画布区域 19 20\t//填充圆点，在画布中心（200,200）绘制一个半径10px的圆形 21\tctx.beginPath(); 22\tctx.arc(x,y,10,0,Math.PI*2,true); 23\tctx.fill(); 24\tctx.closePath(); 25 26\t//填充版权文字 27\tctx.fillStyle=\u0026#34;#ccc\u0026#34;; 28\tctx.font = \u0026#34;12pt Arial\u0026#34;; 29\tctx.fillText(\u0026#34;Helloweba.com\u0026#34;,150,250); 30\t//调用日期并填充到画布中 31\tctx.fillStyle=\u0026#34;#666\u0026#34;; 32\tctx.font = \u0026#34;14pt Verdana\u0026#34;; 33\tctx.fillText(time.getMonth()+1+\u0026#34;-\u0026#34;+time.getDate(),183,170); 34\t35\tctx.save(); //保存当前绘图状态 36 37 // 时间刻度 38 for(var i=0;i\u0026lt;12;i++){ 39 var angle=(Math.PI*2)/12; 40 ctx.beginPath();//开始绘制 41\tctx.font=\u0026#34;12px Arial\u0026#34;; 42 if(i==0||i==3||i==6||i==9){ 43 ctx.fillStyle=\u0026#34;red\u0026#34;; 44 radius=4; 45 }else{ 46 ctx.fillStyle=\u0026#34;blue\u0026#34;; 47 radius=3; 48 } 49 50 ctx.arc(x,y-100,radius,0,Math.PI*2,true); //画圆 51 ctx.fill(); //填充路径 52 trans(ctx,x,y,angle); //刻度分布 53 } 54 ctx.restore(); //恢复上次保存的绘图状态 55 56 sAngle=(Math.PI*2)/60*s; //秒度 57\t//时针转动 58 ctx.save(); 59 ctx.strokeStyle=\u0026#34;red\u0026#34;; 60 ctx.lineWidth=3; 61 trans(ctx,x,y,(Math.PI*2)/60*h); 62 pointer(ctx,x,y,y-40); 63 ctx.restore(); 64 65\t//分针转动 66\tctx.save(); 67\tctx.strokeStyle=\u0026#34;blue\u0026#34;; 68\tctx.lineWidth=2; 69\ttrans(ctx,x,y,(Math.PI*2)/60*m); 70\tpointer(ctx,x,y,y-68); 71\tctx.restore(); 72 73\t//秒针转动 74\tctx.save(); 75\tctx.strokeStyle=\u0026#34;#000\u0026#34;; 76\ttrans(ctx,x,y,sAngle); 77\tpointer(ctx,x,y,y-80); 78\tctx.restore(); 79 80 //数据整理 81 if(s%60==0){ 82\tsAngle=0,s=0,m++; 83 if(m%12==0){ //每十二分 时针旋转一次 84 if(m!=0)h++; 85 if(m%60==0)m=0; 86 } 87 if(h%60==0)h=0; 88 } 89} 90 91//绘制指针 92function pointer(ctx,x,y,z){ 93 ctx.beginPath(); 94 ctx.moveTo(x,y); 95 ctx.lineTo(x,z); 96 ctx.stroke(); 97 ctx.fill(); 98} 99 100 //据坐标旋转 101function trans(ctx,x,y,angle){ 102 ctx.transform(Math.cos(angle), Math.sin(angle), 103 -Math.sin(angle), Math.cos(angle), 104 x*(1-Math.cos(angle)) + x*Math.sin(angle), 105 y*(1-Math.cos(angle)) - y*Math.sin(angle)) 106} 107 108setInterval(\u0026#34;draw()\u0026#34;,1000); 109\u0026lt;/script\u0026gt; 修改后的脚本\r下面是修改后用之前的网站进行转换成pugjs的脚本，懒一点的就直接复制下面代码吧\n1br 2div(style=\u0026#39;position: relative;top: 0px;left: 0px;\u0026#39;) 3 canvas#clock(width=\u0026#39;250\u0026#39;, height=\u0026#39;250\u0026#39;) 4script. 5 var time = new Date(); 6 var h = time.getHours(); //时 7 var m = time.getMinutes(); //分 8 var s = time.getSeconds(); //秒 9 h = h \u0026gt; 12 ? (h - 12) * 5 + parseInt(m / 12) : h * 5 + parseInt(m / 12); //时针 初始位置 10 //===================================== 11 var cc = document.getElementById(\u0026#34;clock\u0026#34;); 12 var x = cc.width/2.0, y = cc.height/2.0, sAngle = 0; //x y 原点 秒针角度变量 13 function draw() { 14 var c = document.getElementById(\u0026#34;clock\u0026#34;); 15 var ctx = c.getContext(\u0026#34;2d\u0026#34;); //获取绘图对象 16 ctx.clearRect(0, 0, c.width, c.height); //清除上次绘制的图形 17 s++;//秒针 18 ctx.fillStyle = \u0026#39;#fff\u0026#39; //填充白色背景色 19 ctx.fillRect(0, 0, c.width, c.height); //设置画布区域 20 //填充圆点，在画布中心（200,200）绘制一个半径10px的圆形 21 ctx.beginPath(); 22 ctx.arc(x, y, 10, 0, Math.PI * 2, true); 23 ctx.fill(); 24 ctx.closePath(); 25 //填充版权文字 26 ctx.fillStyle = \u0026#34;#ccc\u0026#34;; 27 ctx.font = \u0026#34;12pt Arial\u0026#34;; 28 // ctx.fillText(\u0026#34;impressionyang.top\u0026#34;, 10, c.height-10); 29 //调用日期并填充到画布中 30 ctx.fillStyle = \u0026#34;#666\u0026#34;; 31 ctx.font = \u0026#34;14pt Verdana\u0026#34;; 32 ctx.fillText(time.getMonth() + 1 + \u0026#34;-\u0026#34; + time.getDate(), c.width/2, c.height/2); 33 ctx.save(); //保存当前绘图状态 34 // 时间刻度 35 for (var i = 0; i \u0026lt; 12; i++) { 36 var angle = (Math.PI * 2) / 12; 37 ctx.beginPath();//开始绘制 38 ctx.font = \u0026#34;12px Arial\u0026#34;; 39 if (i == 0 || i == 3 || i == 6 || i == 9) { 40 ctx.fillStyle = \u0026#34;red\u0026#34;; 41 radius = 4; 42 } else { 43 ctx.fillStyle = \u0026#34;blue\u0026#34;; 44 radius = 3; 45 } 46 ctx.arc(x, y - 100, radius, 0, Math.PI * 2, true); //画圆 47 ctx.fill(); //填充路径 48 trans(ctx, x, y, angle); //刻度分布 49 } 50 ctx.restore(); //恢复上次保存的绘图状态 51 sAngle = (Math.PI * 2) / 60 * s; //秒度 52 //时针转动 53 ctx.save(); 54 ctx.strokeStyle = \u0026#34;red\u0026#34;; 55 ctx.lineWidth = 3; 56 trans(ctx, x, y, (Math.PI * 2) / 60 * h); 57 pointer(ctx, x, y, y - 40); 58 ctx.restore(); 59 //分针转动 60 ctx.save(); 61 ctx.strokeStyle = \u0026#34;blue\u0026#34;; 62 ctx.lineWidth = 2; 63 trans(ctx, x, y, (Math.PI * 2) / 60 * m); 64 pointer(ctx, x, y, y - 68); 65 ctx.restore(); 66 //秒针转动 67 ctx.save(); 68 ctx.strokeStyle = \u0026#34;#000\u0026#34;; 69 trans(ctx, x, y, sAngle); 70 pointer(ctx, x, y, y - 80); 71 ctx.restore(); 72 //数据整理 73 if (s % 60 == 0) { 74 sAngle = 0, s = 0, m++; 75 if (m % 12 == 0) { //每十二分 时针旋转一次 76 if (m != 0) h++; 77 if (m % 60 == 0) m = 0; 78 } 79 if (h % 60 == 0) h = 0; 80 } 81 } 82 //绘制指针 83 function pointer(ctx, x, y, z) { 84 ctx.beginPath(); 85 ctx.moveTo(x, y); 86 ctx.lineTo(x, z); 87 ctx.stroke(); 88 ctx.fill(); 89 } 90 //据坐标旋转 91 function trans(ctx, x, y, angle) { 92 ctx.transform(Math.cos(angle), Math.sin(angle), 93 -Math.sin(angle), Math.cos(angle), 94 x * (1 - Math.cos(angle)) + x * Math.sin(angle), 95 y * (1 - Math.cos(angle)) - y * Math.sin(angle)) 96 } 97 setInterval(\u0026#34;draw()\u0026#34;, 1000); 至此就能够添加这个时钟到网站里面了，是不是感觉很简单呢。\n后记\r虽然觉得直接拉取被人的东西有点不太厚道，但是我可是最强缝合怪啊，想拿来凑一凑再说哈哈哈。\nimpressionyang","date":"August 7, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/add-canvas-clock-in-pugjs/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"hexo","url":"/tags/hexo/"},{"title":"beautify","url":"/tags/beautify/"}],"timestamp":1596831798,"title":"给pugjs的stun主题添加canvas时钟"},{"authors":[],"categories":[],"content":"\r个人介绍\r姓名： 杨显运\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 性别： 男\n生日： 1997/12/21\n籍贯： 广西省南宁市横县\n手机： 150-7704-0648\n邮箱：impressionyang@outlook.com\n个人主页：https://impressionyang.gitee.io\n教育背景\r辽宁工程技术大学电子与信息工程学院 2016-2020 本科 计算机科学与技术 竞赛经验\r点击下方链接查看奖状证明\n参与2017年移动应用开发大赛获三等奖 参与2018年团体程序设计天梯大赛获东北赛区团体二等奖 参与2018大学生挑战杯校决赛二等奖 参与2018年蓝桥杯获省级二等奖 参与2019年蓝桥杯获省级二等奖 参与2019蓝桥杯获全国三等奖 毕业设计\r基于socket的跨平台通讯软件\r使用开发语言：\tC++、QML\n使用框架：\tQt\n使用通讯技术：\tsocket\n通讯基本原理： 使用Qt下封装好的QTcpSocket进行底层socket通讯的关键技术，由QTcpServer进行服务器端的监听，QTcpSocket进行端到端的通讯。从而达到socket通讯的目的。\n跨平台原理： 使用Qt封装好的一系列类进行底层通讯接口的编写实现，由于Qt的跨平台特性天然使得底层天然支持跨平台。使用Qt Quick技术编写的界面能够保证跨平台的界面始终统一。\n部署配置：此次完成Linux、Windows和Android三大平台的部署，由于成本限制未完成Mac OS、IOS平台部署。Linux以及Windows按部就班分别使用gcc和MINGW配置编译环境，而Android需要配置Google提供的SDK以及Android下C++编译支持工具NDK进行配置，使用EABI交叉编译工具链进行编译环境配置。\n个人项目\rOracle Java8自动安装脚本 Qt GUI(非QML)界面项目创建脚手架 Qt Linux系统监视器(残废中) Deeppin Linux DTK框架入门 自己的第一个Qt小项目-计算器 相关技能\r自学和校内学习的\n使用C/C++语言开发基本程序 使用Qt C++开发桌面应用程序 使用DTK+Qt应用开发应用程序（在国产化Linux发行版deepin中） 使用MySQL数据库配合上述技术开发应用程序 培训\nOPenCV相关开发 应聘方向\r自我评价\r工作热情、热衷于前端应用开发，能够配合团队参与应用的开发工作； 在学校自学新技术的自觉性较强，独立学习多种应用开发框架，有良好的知识接受能力； 自己独立开发了较多的工具应用，有较好的程序独立设计能力。 感谢阅读","date":"June 7, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/about/resume/","series":[],"smallImg":"","tags":[],"timestamp":1591533576,"title":"个人简历"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"说明\r打算是主要打理国内的空间，当然github也会同步发布，是所以使用未备案的域名感觉还是挺不妥当的，还是备案一下，但是我万万没想到的是备案有那么多需要注意的问题\n博客现有问题\r现在博客的一些相关功能已经被我暂停了,后面慢慢恢复 原来的域名无法访问，除非使用pages的二级域名impressionyang.github.io、impressionyang.gitee.io 备案历程[还未备案成功]\r先是在阿里云进行备案，然后发现要使用他们的实例来备案，然后备案的流程好事太长，最终卡在了使用复印件提交管局的步骤，不耐烦然后放弃了，因为还要申请阿里云的幕布 现在在西部数码进行电子化备案，但是因为网站名称退回了一次，但是他们的处理速度挺快，所以在继续备案 后记\r原来以为备案网站很简单，原来还是太年轻了，以后打算使用西部数码的虚拟主机+GitHub Pages+Gitee Pages三方面进行文章的发布了\n祝我顺利\nimpressionyang","date":"April 21, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/the-blog-is-put-on-record/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"daily","url":"/tags/daily/"},{"title":"text","url":"/tags/text/"}],"timestamp":1587489007,"title":"最近网站备案中。。。"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r以下rEFInd的arckwiki词条的内容：\nrEFInd 是一个 UEFI 启动管理器。它是 rEFIt （不再维护）的一个分支并且针对非 Mac 硬件修复了若干问题。它被设计为平台无关，可启动多个操作系统。\n使用rEFInd的需求是我原来使用的是bootctl这个启动引导程序,虽然简单好用,但是只有黑白界面难免有点单调,所以就想使用一个比较漂亮的但是文件结构又简洁的bootloader,所以grub就被丢弃了,虽然它的却很强大,但是文件结构有点复杂,配置影响因素有点多\n安装rEFInd\r1sudo pacman -S refind-efi 配置\r备份原有引导\r首先备份移除原有的bootloader,我之前用的是bootctl,所以需要备份/boot/loader文件夹和/boot/EFI/systemd/systemd-bootx64.efi文件\n1cp -r /boot/loader ~/loader 2cp -r /boot/EFI/systemd ~/systemd 配置rEFInd\r安装rEFInd引导文件至启动分区:\n1sudo refind-install 一般情况下能够直接进行安装,如果出问题请查看archwiki的rEFInd的手动安装引导文件小节,请点击这里\n配置主题\rrEFInd的主题可以在github中自己搜索得到\n将自己心仪的主题下载下来之后将其解压至/boot/refind/themes中,在/boot/refind/refind.conf的末尾加入include themes/你下载的主题/theme.conf即可生效.\n配置自定义启动项\r编辑文件/boot/EFI/refind/refind.conf中向下滑差不多到3/4位置的位置中的Arch Linux小节,将其中的文件配置成自己的启动方式,下面的例子是我的\n1menuentry \u0026#34;Arch Linux\u0026#34; { 2 icon /EFI/refind/themes/refind-ambience/icons/os_arch.png 3 #volume \u0026#34;Arch Linux\u0026#34; 4 loader /vmlinuz-linux 5 initrd /amd-ucode.img 6 initrd /initramfs-linux.img 7 options \u0026#34;root=PARTUUID=7ce1b087-1f97-4a98-ac50-408353207b92 rw\u0026#34; 8 submenuentry \u0026#34;Boot using fallback initramfs\u0026#34; { 9 initrd /initramfs-linux-fallback.img 10 } 11 submenuentry \u0026#34;Boot to terminal\u0026#34; { 12 add_options \u0026#34;systemd.unit=multi-user.target\u0026#34; 13 } 14 #disabled 15} 可以看到的的启动的icon是使用主题里面提供的,可以使得启动的界面更加统一\n后记\rrEFInd启动引导程序还是很秀的,主题也挺美观,下面放一张效果图(虚拟机中的)\nimpressionyang","date":"March 30, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/arch-refind-bootloader-efi/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"rEFInd","url":"/tags/refind/"},{"title":"boot loader","url":"/tags/boot-loader/"}],"timestamp":1585560919,"title":"Arch Linux切换rEFInd开机引导程序"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"先导\r因为有需求使用Qt的文件I/O操作,所以做此记录以供后用\n使用\r简单使用以及说明\r简单的使用基本上分4步:\n定义文件变量 打开文件 执行文件I/O操作 关闭文件 简单使用读取文件:\n1 QFile file(\u0026#34;your file path\u0026#34;); 2 file.open(QFile::ReadOnly); 3 QByteArray buf; 4 while(file.read(buf.data(),1024)\u0026gt;0){ 5 cout\u0026lt;\u0026lt;buf; 6 buf.clear(); 7 } 8 file.close(); 上述文件读取操作中,使用的是C++习惯下的read函数,其使用也和C++的read函数差不多,需要讲解一下的是QFile的open函数的参数,有以下的表列\n参数 说明 NotOpen 不打开文件 ReadOnly 只读 WriteOnly 只写 ReadWrite 可读写 Append 追加 Truncate 尽可能在打开文件前删除 Text 限定文本操作,读文件的话结束符翻译为文本的\\n,写文件则结尾时写入当前系统的文本结束符,例如win的\\n\\r Unbuffered 不能使用缓存流I/O NewOnly 在创建文件的时候确保文件是不存在的,不然文件不能打开 ExistingOnly 在读取文件是确保文件是存在的,不然文件不能打开 简单写入文件\n1 QFile file(\u0026#34;your file path\u0026#34;); 2 file.open(QFile::WriteOnly | QFile::Truncate); 3 QByteArray buf(\u0026#34;text to write\u0026#34;); 4 file.write(buf); 5 file.close(); 使用stream进行读写\r使用stream进行读写时可以使用输入(\u0026gt;\u0026gt;)输出(\u0026lt;\u0026lt;)流符号进行格式化输入输出,读写方便,在Qt的文件I/O中可以使用QTextStream和QDateStream来对文件进行操作\n读取文件:\n1 QFile file(\u0026#34;in.txt\u0026#34;); 2 if (!file.open(QFile::ReadOnly | QFile::Text)) 3 return; 4 5 QByteArray buf; 6 QTextStream in(\u0026amp;file); 7 while (!in.atEnd()) { 8 in\u0026gt;\u0026gt;buf.data(); 9 cout\u0026lt;\u0026lt;buf; 10 buf.clear(); 11 } 12 file.close(); 写入文件:\n1 QFile file(\u0026#34;out.txt\u0026#34;); 2 if (!file.open(QFile::WriteOnly | QFile::Text)) 3 return; 4 5 QTextStream out(\u0026amp;file); 6 out \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 7 out.flush(); 8 file.close(); 后记\rQt的文件操作对于一个应用软件来说是一个重要的使用方式,虽然上面讲述了Qt文件I/O的基本操作,但是其使用方式还有很多,这仅仅是最基本的使用方式而已,以后还有很多东西需要学习的\nimpressionyang","date":"March 29, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/qt-qfile-note/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"C++","url":"/tags/c++/"},{"title":"Qt","url":"/tags/qt/"},{"title":"QFile","url":"/tags/qfile/"}],"timestamp":1585511418,"title":"Qt文件操作QFile"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"先导\r最近有使用QT的UDP广播,所以记录这篇帖子记录一下\n讲解\r什么是UDP广播,我就不搬百科的内容了,就按照我的一点理解来说吧\nUDP是一种网络进程间通信的技术,一般和TCP一起出现,UDP的通信优势是速度快、不需要确定对方IP地址，但是缺点是连接不可靠。而UDP广播是UDP下的一种通讯手段，他作为广播发送端（使用writeDatagram()方法）时可以在当前网络下的广播地址中进行发送广播信息，而任何接收端(使用readDatagram()方法)都能接收到服务器当前发送的广播信息\n代码实例\r只写出关键的代码，完整带图形界面的测试项目已经上传至我的github 发送端\r1UdpBrocastServer::UdpBrocastServer(QString msg) { 2 brocast_server = new QUdpSocket(); 3 if (!msg.isEmpty()) { 4 brocast_server-\u0026gt;writeDatagram(msg.toLocal8Bit(), QHostAddress::Broadcast, 5 10086); 6 } else { 7 qDebug() \u0026lt;\u0026lt; \u0026#34;brocast server: msg is empty!\u0026#34;; 8 } 9} 接收端\r1UdpBrocastClient::UdpBrocastClient() { 2 brocast_client = new QUdpSocket(); 3 brocast_client-\u0026gt;bind(10086, QUdpSocket::ShareAddress); 4 5 QObject::connect(brocast_client, \u0026amp;QUdpSocket::readyRead, this, [=]() { 6 // 7 QByteArray datagram; 8 datagram.resize(brocast_client-\u0026gt;pendingDatagramSize()); 9 brocast_client-\u0026gt;readDatagram(datagram.data(), datagram.size()); 10 emit getBrocastMsg(QString(datagram)); 11 }); 12} 测试\r带图形界面的测试\nimpressionyang","date":"March 28, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/qt-udp-brocast/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"C++","url":"/tags/c++/"},{"title":"Qt","url":"/tags/qt/"}],"timestamp":1585425427,"title":"Qt UDP广播"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r写这篇帖子的原因是我很想在博客网站下面添加网站的运行时间,网上虽然有教程是怎么添加的,但是他们演示的主题大都是用ejs或者是wig来编写的,而我使用的这个个人很喜欢的stun主题却是用pugjs编写的,实在是很想用,所以根据语法的转换规则修改了一份pug文件下添加的脚本来使用,美滋滋\n脚本\r语法参考的话可以去这里 原来的ejs脚本\n1\u0026lt;div\u0026gt; 2\u0026lt;span id=\u0026#34;timeDate\u0026#34;\u0026gt;载入天数...\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026#34;times\u0026#34;\u0026gt;载入时分秒...\u0026lt;/span\u0026gt; 3\u0026lt;script\u0026gt; 4 var now = new Date(); 5 function createtime() { 6 var grt= new Date(\u0026#34;08/13/2018 00:00:00\u0026#34;); 7 now.setTime(now.getTime()+250); 8 days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 9 hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 10 if(String(hnum).length ==1 ){hnum = \u0026#34;0\u0026#34; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 11 mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \u0026#34;0\u0026#34; + mnum;} 12 seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 13 snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \u0026#34;0\u0026#34; + snum;} 14 document.getElementById(\u0026#34;timeDate\u0026#34;).innerHTML = \u0026#34;本站已安全运行 \u0026#34;+dnum+\u0026#34; 天 \u0026#34;; 15 document.getElementById(\u0026#34;times\u0026#34;).innerHTML = hnum + \u0026#34; 小时 \u0026#34; + mnum + \u0026#34; 分 \u0026#34; + snum + \u0026#34; 秒\u0026#34;; 16 } 17setInterval(\u0026#34;createtime()\u0026#34;,250); 18\u0026lt;/script\u0026gt; 19\u0026lt;/div\u0026gt; 转换后的pugjs脚本\n1div 2 span#timeDate 载入天数... 3 span#times 载入时分秒... 4 script. 5 var now = new Date(); 6 function createtime() { 7 var grt= new Date(\u0026#34;08/13/2018 00:00:00\u0026#34;); 8 now.setTime(now.getTime()+250); 9 days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 10 hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 11 if(String(hnum).length ==1 ){hnum = \u0026#34;0\u0026#34; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 12 mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \u0026#34;0\u0026#34; + mnum;} 13 seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 14 snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \u0026#34;0\u0026#34; + snum;} 15 document.getElementById(\u0026#34;timeDate\u0026#34;).innerHTML = \u0026#34;本站已安全运行 \u0026#34;+dnum+\u0026#34; 天 \u0026#34;; 16 document.getElementById(\u0026#34;times\u0026#34;).innerHTML = hnum + \u0026#34; 小时 \u0026#34; + mnum + \u0026#34; 分 \u0026#34; + snum + \u0026#34; 秒\u0026#34;; 17 } 18 setInterval(\u0026#34;createtime()\u0026#34;,250); 然后把上述脚本添加到主题的layout/_partials/footer/footer.pug文件中(不同主题可能文件不一样,请自行参考)即可在网页底部显示网站运行时间了OvO,不过要注意修改一下var grt= new Date(\u0026quot;08/13/2018 00:00:00\u0026quot;);中的起始时间哦!\n效果 后记\r后来发现了一个神奇的网站可以帮助从html转到pug,请戳这里,难受,虽然上面的不难翻译,但是用这个网站不费力是真的\u0026hellip;.\nimpressionyang","date":"March 27, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/add-runing-time-in-pug-script-for-hexo/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"hexo","url":"/tags/hexo/"},{"title":"beautify","url":"/tags/beautify/"}],"timestamp":1585349948,"title":"为主题用pugjs编写的hexo博客添加网站运行时间"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r经过上一次的在配置之后能够使用图形界面了,但是会发现有一些功能是使用不了的,包括一切笔记本上的快捷键,原因是缺少了相配套的小工具进行配置,本期就是讲讲这些相关配置的\n再更新中\u0026hellip; 电池及屏幕亮度\r刚安装好KDE桌面没有安装电源相关组件,导致电源以及与之相关的亮度功能受到影响,需要安装相关的工具\n1sudo pacman -S acpid tlp powerdevil 安装好相关组件之后重启应该就能看到相关的功能可以使用了\n声音托盘工具\r刚安装好KDE桌面没有安装声音工具是不能调节声音的,除非使用外部功放设备,安装可选的工具有两个\n一个是kmix,能够提供声音调节、选择播放设备和调整输入设备等功能,但是有一个缺点就是UI有点不太好看 1sudo pacman -S kmix 另一个就是plasma-pa,看这个名字就知道这个是直接配合Plasma使用的 1sudo pacman -S plasma-pa 蓝牙托盘工具以及蓝牙功能\r蓝牙功能也是不经配置的话会有几率不能直接使用的,安装之后还需要进行配置使得蓝牙服务能够开机自启\n1sudo pacman -S bluez bluez-utils bluedevil 配置开机启动:\n1sudo systemctl enable bluetooth 编辑配置 配置好开机自启动配置 编辑/etc/bluetooth/main.conf，使用vim工具sudo vim /etc/bluetooth/main.conf 在[Policy]下添加项目AutoEnable=true 配置蓝牙耳机相关 编辑/etc/pulse/system.pa，使用vim工具sudo vim /etc/pulse/system.pa,当然使用图形文本编辑工具也可以 在文中插入以下项目 1load-module module-bluetooth-policy 2load-module module-bluetooth-discover 多屏功能\r多屏输出这个功能的缺失是最近发现的,我使用的是X11+xrandr,需要安装一个能够图形配置xrandr的工具,找来找去也只在archwiki中找到了arandr这个图形界面工具.\n1sudo pacman -S arandr 就可以通过这个工具配置图形输出了,只要通过输出-\u0026gt;输出设备选择设备然后激活使用并在面板中拖放好相应位置皆即可\nimpressionyang","date":"March 26, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/archlinux-install-3/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"install","url":"/tags/install/"}],"timestamp":1585216222,"title":"Archlinux安装篇（三） KDE配套小工具"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"先导\r本贴在手机端因为mermaid插件的问题显示会超出屏幕，以后在想办法解决，目前建议使用电脑浏览\n持续更新中\u0026hellip; 本贴是为了记录因为沦为需要进行时序图和流程图进行mermaid图像的学习而写下的\nHexo 相关配置\r要想在Hexo中使用mermaid图形的话需要安装hexo-filter-mermaid-diagrams这个插件并且配置相关的设置，该插件是由作者Frank_Fang修改编写的，并且在他的github项目中给出了很详细的配置说明,本贴就节选我的配置来说明。\n安装插件\r1cnpm install hexo-filter-mermaid-diagrams --save 配置插件\r首先配置Hexo的_config.yml\n需要在配置文件的文末添加\n1# mermaid chart 2mermaid: ## mermaid url https://github.com/knsv/mermaid 3 enable: true 4 # default true 5 version: \u0026#34;7.1.2\u0026#34; 6 # default v7.1.2 7 options: 8 # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js 9 #startOnload: true // default true 然后在配置主题的相关页面片段使得网页能够是别到插件生成的mermaid图并渲染(需要一定的时间,主要是配置的js源比较慢),因为的使用的主题stun的页面片段是用pug编写的,所以使用的是作者说明的配置来的,如果使用的是ejs或者其他文件编写的请查看作者的github是怎么说明的,根据作者推荐的配置是在在after_footer.pug文件里面,但是我的这个主题并没有这个文件,所以我选择直接使用footer.pug来进行配置,可能会比原来的慢一点\u0026hellip;\n于是,在主题/layout/footer/footer.pug里面添加以下内容\n1if theme.mermaid.enable == true 2 script(type=\u0026#39;text/javascript\u0026#39;, id=\u0026#39;maid-script\u0026#39; mermaidoptioins=theme.mermaid.options src=\u0026#39;https://unpkg.com/mermaid@\u0026#39;+ theme.mermaid.version + \u0026#39;/dist/mermaid.min.js\u0026#39; + \u0026#39;?v=\u0026#39; + theme.version) 3 script. 4 if (window.mermaid) { 5 var options = JSON.parse(document.getElementById(\u0026#39;maid-script\u0026#39;).getAttribute(\u0026#39;mermaidoptioins\u0026#39;)); 6 mermaid.initialize(options); 7 } 至此,Hexo方面的配置基本完成,接下来就讲讲mermaid相关的语法\nmermaid语法\rmermaid的代码块标识是mermaid 创建一个代码块并将相关语句添加进去即可 如果想看到原汁原味的语法请到mermaid-js作者的git pages页面查看,里面有完整的语法支持,包括流程图、时序图、类图、活动土、甘特图和饼图，我这里只是节选一些我需要的进行简化抽取并进行简单的翻译\n也可以体验mermaid-js作者提供的在线demo 流程图\r程序流程图是用规定的符号描述一个专用程序中所需要的各项操作或判断的图示。这种流程图着重说明程序的逻辑性与处理顺序，具体描述了微机解题的逻辑及步骤。当程序中有较多循环语句和转移语句时，程序的结构将比较复杂，给程序设计与阅读造成困难。程序流程图用图的形式画出程序流向，是算法的一种图形化表示方法，具有直观、清晰、更易理解的特点。-百度百科\u0026quot;程序流程图\u0026quot;\n程序流程图的mermaid语法基本如下:\n1graph 方向描述 2 组件相关语句 3 ... 其大致能分成:\n方向描述 组件 线条 子图 方向描述\r方向描述是用来规定流程图的方向的,具体语法如下\n选项 说明 TB 方向从上至下 BT 方向从下至上 LR 方向从左至右 RL 方向从右至左 组件\r组件是用来表示相关过程的,由id和括号组成,id是用来标识组件的的,具体语法如下\ntext是自定义文本 id可以用别的英文名替换 选项 说明 id(text) 圆角矩形 id[text] 矩形 id{text} 菱形 id\u0026gt;text] 旗帜形 id((text)) 圆形 线条\r线条是流程图各个组件之间的联系\ntext是自定义文本 选项 说明 --- 简单线条,无箭头 --\u0026gt; 有箭头的简单线条 --text--- 无箭头简单线条附带文字 --text--\u0026gt; 有箭头简单线条附带文字 === 无箭头粗线条 ==\u0026gt; 有箭头粗线条 ==text=== 带文字无箭头粗线条 ==text==\u0026gt; 带文字有箭头粗线条 -.-- 无箭头虚线 -.-\u0026gt; 有箭头虚线 -.text.-- 带文字无箭头虚线 -.text.-\u0026gt; 带文字有箭头虚线 由此,一个流程图所需的语法已经介绍完毕,子图我现在运用过少先不介绍了,接下来是一份基本例子\n1graph TB 2 start(开始)--\u0026gt;opt1[事件1] 3 opt1--\u0026gt;if1{判断1} 4 if1--Y--\u0026gt;opt2[事件2] 5 opt2-.如果累了.-\u0026gt;opt4((休息一下)) 6 if1--N--\u0026gt;opt3[事件3] 7 opt2--\u0026gt;endd(结束) 8 opt3--\u0026gt;endd graph TB\rstart(开始)--\u003eopt1[事件1]\ropt1--\u003eif1{判断1}\rif1--Y--\u003eopt2[事件2]\ropt2-.如果累了.-\u003eopt4((休息一下))\rif1--N--\u003eopt3[事件3]\ropt2--\u003eendd(结束)\ropt3--\u003eendd\r类图\r类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。类图也可用于数据建模。-百度百科\u0026quot;类图\u0026quot;\n类图的创建语法基本如下\n1classDiagram 2 类图的语句 3 ... 其内容大致能分为\n类定义 注释 关系 类定义\r类图最主要的元素就是类了，定义一个类的方法有多种多样，建议使用比较像编程语言的语法创建类\n1class NAME{ 2 成员变量相关 3 成员函数相关 4} 通过上述语法可以在类图中创建一个类，下面讲讲成员变量和成员函数的相关语法\n可见性 类的成员有着可见性这一特征，在类图中一般是可见性 类成员直接连着写的，可见性分类如下\n符号 说明 + 公有的 public - 私有的 private # 保护的 protected ~ 包内的 package 成员变量和成员函数 mermaid通过()来判定成员变量和成员函数，带有()的就是成员函数,否则为成员变量\n加上可见性组合成员变量和成员函数就可以建立一个简单的类了\n1classDiagram 2 class Student{ 3 -String name; 4 -int age; 5 +Student(String name,int age); 6 } classDiagram\rclass Student{\r-String name;\r-int age;\r+Student(String name,int age);\r+getAge() int;\r}\r注意1:mermaid中想使用List\u0026lt;int\u0026gt;这样的通用参数或者返回值的话是不能直接使用\u0026lt;\u0026gt;符号的,需要使用~~来代替,也就是List~int~这样的形式。 注意2:mermaid函数返回值需要写在函数声明后,记住有空格,不能写在可见性后 注释\r注释分为类的注释和类图中的注释\nclassDiagram\rclass Animal{\r+String gender\r+isMammal()\r+mate()\r}\rAnimal : +int age\rclass Duck{\r+String beakColor\r+swim()\r+quack()\r}\rclass Fish{\r-int sizeInFeet\r-canEat()\r}\rclass Zebra{\r+bool is_wild\r+run()\r}\rAnimal \u003c|-- Duck\rAnimal \u003c|-- Fish\rAnimal \u003c|-- Zebra\r时序图\r时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。-百度百科\u0026quot;时序图\u0026quot;\n时序图的创建语法基本如下\n1sequenceDiagram 2 时序图语句 3 ... 其内容大致能分为:\n参与者 消息线 标注 循环 判断 参与者\r参与者是参消息的实体,其创建语法如下:\n1participant name1 2participant name2 as 名字2 第1行是创建一个参与者,名字为name1,第2行是创建一个参与者名字叫做name2,但是它有一个别名叫名字2\n消息线\r消息线是时序图里面各个实体之间相互通信的联系,其说明如下\n语法 说明 -\u0026gt; 无箭头的实线 --\u0026gt; 无箭头的虚线 -\u0026gt;\u0026gt; 有箭头的实线 --\u0026gt;\u0026gt; 有箭头的虚线 -x 末端为叉的实线 --x 末端为叉的虚线 注意:由此参与者+消息线就会合并就会发生信息,一般语法是:\n1参与者 消息线 另一参与者: 信息 2#例子 name1-\u0026gt;\u0026gt;name2:msg 标注\r标注能够在时序图的某个时间点为实体标注一些信息,一般由Note 位置 实体：文字描述来组成，其位置说明如下\n选项 说明 Note left of 标注在实体的左侧 Note right of 标注在实体的右侧 Note over 标注在实体上 循环\r循环是在一个时间段内符合某种条件时重复做一件事情,其基本语法如下:\n1loop 循环的条件 2 循环体描述语句 3end 判断\r遇到一些需要根据不同情况进行分支选择的时候就需要用到判断语句了,其语法大致有两种,一种是有多分支的,一种是只有一条分支的\n多分支:\n1alt 分支条件1 2 分支语句1 3 ... 4else 分支条件2 5 分支语句2 6 ... 7else 分支条件3 8 ... 9 ... 10end 单分支,即只有一个条件操作:\n1opt 条件 2 执行语句 3 ... 4end 基本上时序图就是以上的常用语法了,下面给出一个实例:\nsequenceDiagram\rtitle: 实例\rparticipant teacher as 老师\rparticipant stu as 学生\ropt 起床了\nNote right of stu:上学\nNote left of teacher:上课\nend\nstu-\u0026raquo;teacher:老师好\nteacher-\u0026raquo;stu:同学们好,请坐\nopt 老师应答完毕\nNote over stu:坐下\nend\nloop 授课时间\nNote right of teacher:老师上课\nalt 同学提问\nstu-\u0026raquo;teacher:问题\nteacher-\u0026raquo;stu:答案\nelse 老师提问\nteacher-\u0026raquo;stu:问题\nstu-\u0026raquo;teacher:回答\nelse 下课时间到了\nNote right of teacher:下课\nend\nend\nopt 下课\nteacher-\u0026raquo;stu:同学们再见\nstu-\u0026raquo;teacher:老师再见\nend\nNote over teacher,stu:继续日常至放学时间\nopt 放学了\nNote left of teacher:回家\nNote right of stu:回家\nend\n甘特图\r以下节选自百度百科\u0026quot;甘特图\u0026quot;的信息:\n甘特图（Gantt chart）又称为横道图、条状图(Bar chart)。其通过条状图来显示项目，进度，和其他时间相关的系统进展的内在关系随着时间进展的情况。以提出者亨利·劳伦斯·甘特（Henry Laurence Gantt）先生的名字命名。\n","date":"March 21, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/markdown-note-mermaid/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"markdown","url":"/tags/markdown/"},{"title":"UML","url":"/tags/uml/"},{"title":"hexo","url":"/tags/hexo/"},{"title":"mermaid","url":"/tags/mermaid/"}],"timestamp":1584829894,"title":"Markdown的时序图、流程图、和甘特图+Hexo的相关配置"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"问题复现\r这次崩溃的原因是安装主题的时候手贱终止了一次然后就出了问题，导致hexo的各种命令如clean、generate、server等一直报警告并且导致网页资源的渲染出问题从而使得网站运行异常\n而这次发帖是为了记录本次的修复过程以提供后用\n修复的原理\r我们都知道hexo的目录下面有一个node_modules文件架夹和一个package.json文件（安装插件后会自动生成），文件夹是保存了各个插件的文件依赖，json文件是保存了hexo的各个依赖组件，使用npm install可以根据此文件进行批量安装。\n更新/安装中断或者操作插件的时候导致的异常一般是因为node_modules文件夹里面的文件出问题或者丢失\n所以我们遇到什么困难也不要怕，微笑着干掉它，没错，直接把node_modules文件夹整个删掉、删掉、删掉。\n然后就没有问题了，因为整个问题的根源已经没有了233，开玩笑的，基本上只要把插件重新一个个安装完基本上就没事了，当然，如果你在折腾主题的话还需要先把主题会复制折腾之前哦。\n恢复\r既然知道了原因，那么就直接使用命令修复它吧\n删除node_modules\n1rm -rf node_modules 恢复主题至折腾之前，然后重新安装插件\n1cnpm install --save 重新生成网页测试\n1hexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s 如果没出问题的话基本上博客网页又能恢复正常咯\nimpressionyang","date":"March 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/hexo-broken-fix-note01/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"hexo","url":"/tags/hexo/"}],"timestamp":1584740616,"title":"记录一次Hexo的崩溃修复"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\rmaybe a new fcitx. Next generation of fcitx. Fcitx 5 is a generic input method framework released under LGPL-2.1+.\n以上是github上记录的fcitx5的仅有的寥寥几笔，想看到更多的内容请查看老K的文章\n这篇帖子是记录我安装Fcitx5的经历，反正是折腾了很久才配置成功的，也看了很多其他人的配置，记录成功安装方法以留作以后参考\n安装\r由于fcitx5的相关组件已经全部被Arch收录至community源中了，所以这也是我想要安装它的一个原因。\n需要安装fcitx5 fcitx5-chinese-addons fcitx5-gtk fcitx5-qt kcm-fcitx5 fcitx5-rime\n1sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-gtk fcitx5-qt kcm-fcitx5 fcitx5-rime 其中，fcitx5是核心组件，fcitx5-chinese-addons是一个中文插件，包含了Fcitx的IME组件，fcitx5-gtk fcitx5-qt是Fcitx5的gtk模块和qt模块，kcm-fcitx5是Fcitx5的KDE设置模块，fcitx5-rime是Fcitx5的中州韵输入法\n配置\r我就是在配置Fcitx5的时候吃了大亏，所以要仔细看清楚配置步骤，首先需要确定你的图形管理是X11的还是Wayland的，确定的方法可以在控制台输入\n1loginctl show-session 2 -p Type 或者\n1loginctl show-session \u0026#34;$XDG_SESSION_ID\u0026#34; -p Type 如果有输出x11的字样就是X11的，否则为Wayland的。\n由此，会有两种配置方法，两者由自己的情况自己选择其中的一种\nX11\rX11需要配置的文件有~/.xprofile和~/.xinitrc\n在~/.xprofile中添加\n1export GTK_IM_MODULE=fcitx5 2export XMODIFIERS=@im=fcitx5 3export QT_IM_MODULE=fcitx5 4fcitx5 \u0026amp; 注意：添加fcitx5 \u0026amp;是为了能让Fcitx5登陆时启动 在~/.xinitrc中则添加\n1export GTK_IM_MODULE=fcitx5 2export XMODIFIERS=@im=fcitx5 3export QT_IM_MODULE=fcitx5 注意：上述内容需要添加在exec $(get_session)之前 Wayland\rWayland则需要编辑的文件是~/.pam_environment\n在~/.pam_environment中添加\n1GTK_IM_MODULE DEFAULT=fcitx5 2QT_IM_MODULE DEFAULT=fcitx5 3XMODIFIERS DEFAULT=@im=fcitx5 配置总结\r以上就是Fcitx5的常规配置过程了，需要注意的有几点：\n添加fcitx5 \u0026amp;是为了能让Fcitx5登陆时启动 Xprofile添加的内容需要添加在exec $(get_session)之前 若是在Wayland下配置开机不能启动Fcitx5（少数异常情况）请自行添加Fcitx5的开机启动 一些问题的解决\r设置输入法\r上面其实已经安装了Fcitx5的图形设置界面了，其位置在系统设置-\u0026gt;区域设置-\u0026gt;输入法里面，可以对Fcitx5进行自定义的一些配置。\n主题不好看\r如果觉得下载的主题配置不好看，KDE下可以直接在某个面板中添加小部件输入法面板即可自动使用当前的KDE主题风格，而且可以覆盖设置字体大小和候选字显示方向，很舒服\n具体可以看我的效果哈哈哈。\nwine或者deepin-wine的一些配置\r原因：locale设置或者启动环境的问题\n解决方法： 通过脚本设置locale和环境启动软件\n其中，deepin-wine的配置最容易，因为deepin-wine的软件本身都是由脚本启动的，只需要添加以下内容\n1env locale=zh_CN 2export XIM=\u0026#34;fcitx5\u0026#34; 3export GTK_IM_MODULE=\u0026#34;fcitx5\u0026#34; 4export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; 5export QT_IM_MODULE=\u0026#34;fcitx5\u0026#34; 至/opt/deepinwine/apps/对应软件/run.sh 内的运行语句之前即可，怕出问题可直接添加至文件首。\n而wine的话需要自己在写一个run.sh，在其中添加上述环境设置后写一个运行语句即可，例子如下：\n1#!/bin/sh 2env locale=zh_CN 3export XIM=\u0026#34;fcitx5\u0026#34; 4export XMODIFIERS=\u0026#34;@im=fcitx5\u0026#34; 5export GTK_IM_MODULE=\u0026#34;fcitx5\u0026#34; 6export QT_IM_MODULE=\u0026#34;fcitx5\u0026#34; 7 8wine ~/.wine/drive_c/Program\\ Files\\/QQ/Bin/QQ.exe 使用nohup sh ru.sh \u0026amp;\u0026gt;/dev/null \u0026amp;即可后台运行该脚本\n待解决\rwps office的中文输入，编辑/usr/bin/wps添加环境设置也无效 难搞，但是Fcitx5是真的香(๑˃̵ᴗ˂̵)و，内存占用也很舒服 impressionyang","date":"March 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/fcitx5-install-note/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"KDE","url":"/tags/kde/"},{"title":"KDE Wallet","url":"/tags/kde-wallet/"}],"timestamp":1584722275,"title":"记一次Fcitx5的安装"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"C++和Java的变量对比\r本贴创建的原因是本人需要做一个C++和Java之间进行socket通信的时候想要确定一下两者之间变量的内存占用情况，经过验证测试得出的结果用于以后用来进行验证\n本次的结果均是在32位系统中得到的，64位的操作系统的内存占用情况可能有所不同！ 对比的表格如下:\rC++ usage Java usage short 2 bytes short 2 bytes int 4 bytes int 4 bytes long 4 bytes long 8 bytes long long 8 bytes float 4 bytes float 4 bytes double 8 bytes double 8 bytes long double 12 bytes bool 1 byte boolean 1 byte char 1 byte char 2 bytes unsigned char 1 byte byte 1 bytes 后记\r在进行跨平台的socket套接字连接是需要注意变量内存问题\nimpressionyang","date":"March 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/cpp-java-variable-diff/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"Java","url":"/tags/java/"},{"title":"C++","url":"/tags/c++/"}],"timestamp":1584713315,"title":"C++和Java的变量对比"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"解决KDE下KDE Wallet重装系统后每次登陆需要输入密码\r在每次重装或者配置桌面后kdewallet总是在登陆系统之后提示输入密码，虽然在输入密码后能够继续正常使用，但是每次登陆系统都需要输入一次密码还是很烦人的，所以记录本帖以留作后用\n出现的原因\r在重新配置桌面或者重装系统之后KDE Wallet所需要的一些必备需要依赖组件未能找到，所以导致不能正确运行KDE Wallet，所以只要安装其所需的组件即可。而其所需的但是未能自动安装的依赖组件正是kwallet-pamExtra\n解决方案\r安装缺失的组件\n1sudo pacman -S kwallet-pam 为了保险起见，查看个人目录下是否存在~/.kde4/share/apps/kwallet文件夹，如果存在则将其删除或者重命名以避免出现冲突，并且还需要确定使用的钱包名为kdewallet并且密码为当前用户的密码。\n如此便可完全正常使用KDE Wallet\n本贴解决方案参考arch wiki的KDE Wallet小节中。\nimpressionyang","date":"March 15, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/kde-wallet-login-config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"KDE","url":"/tags/kde/"},{"title":"WDE Wallet","url":"/tags/wde-wallet/"}],"timestamp":1584275183,"title":"解决KDE下KDE Wallet重装系统后每次登陆需要输入密码"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"Hexo + Git Pages搭建个人博客（一）\r期待已久的Hexo部署教程终于来了，本次发帖是在经过较长时间地使用Hexo之后才发出的，一成功就发感觉有点不稳，本贴主要是记录了本博客站的最终搭建方案，会分为几个部分，这次就讲讲怎么把Hexo运行起来的方法。\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n安装和配置Hexo\r安装\r安装前准备\r由于Hexo依赖Node.js，所以必不可少的使用了npm来进行安装插件，所以需要提前安装好Node.js和npm，但是由于npm使用的是境外服务器，所以推荐安装一下淘宝的国内镜像cnpm，还有安装主题文件时可能会使用到git工具，所以也需要安装，具体所有安装如下：\n安装Node.js和npm 1sudo pacman -S nodejs npm 使用npm -v和node -v能看到以下输出即可\n安装cnpm 1npm install cnpm -g --registry=https://registry.npm.taobao.org 安装git 1sudo pacman -S git 顺利安装完成即可\n安装Hexo至本地blog文件夹并配置\r安装好环境依赖以后就可以开始着手准备Hexo的安装了，基本上安装除了主题使用git和部署Hexo使用hexo命令外其他都是用cnpm工具，当然，如果你能魔法上网的话用npm也可以\n安装Hexo\r需要使用超级用户权限才可以安装到全局环境下，这样可以在本地文件系统的任一位置部署Hexo，比较方便\n1sudo cnpm install -g hexo 顺利安装完成后在控制台终端里面输入hexo -v有如下输出即可\n配置\r部署Hexo博客根目录\r进入到要创建博客的文件目录 以下的YourHexoBlogName都改为你自己需要的文件夹名称 开始部署：\n1hexo init YourHexoBlogName 在经历一段时间的部署后就会在当前目录下多出一个名为YourHexoBlogName的文件夹，里面的目录结构大概如下\n1. 2├── _config.yml #Hexo的配置文件 3├── node_modules #插件及环境目录 4├── package.json #安装的所有包的json归档文件 5├── scaffolds #配置和资源未使用到，不讲 6├── source #存放资源文件夹 7├── themes #存放主题的文件夹 8└── yarn.lock #配置未用到，不讲 如果未与上述相符的话要么是本贴太老旧，要么就是你没有安装对咯\n安装主题\rHexo官方收录了大量的精美博客主题，只需要前往主题收录地址进行下载，然后解压至theme目录下即可，一般主题都会有一个README文件，里面一般都会讲解说明主题的文件夹名称和主题名称，对好入座后在Hexo的配置文件_config.yml的theme:后面填写对应主题即可。\n配置Git Page服务\r一般来说一般人是没有个人域名的，更不用说个人服务器了，本贴是基于不需要依托付费的在线方案进行部署Hexo的，所以推荐使用GitHub或者Gitee进行在线部署，这两个在线的托管平台都提供了Git Pages服务，但是这两者之间是有一定差异的，下面讲解：\nGitHub：提供免费的公开仓库Pages服务，上传自动部署更新，使用似有的仓库进行Pages需要付费；属于境外服务器，国内访问速度不稳定，不推荐使用上传仓库中的图片，建议使用图床。 Gitee：提供免费公共似有仓库的Pages服务，但是上传不能自动部署更新，需要手动更新 ，自动更新需要付费；属于国内服务器，国内访问速度很快，可以使用上传仓库中图片。 根据上述优缺点可以自行进行选择Pages服务的提供商，我个人是使用gitee搭建图床+github搭建博客网站的方法，gitee由于在国内访问图片较快，可以搭建私有仓库并开启Pages服务，每次添加图片可以去更新一下，github可以自动部署更新，无脑上传很方便，外国友人也可访问，大厂风范，使用舒服。\n本贴只介绍gitee作为博客网站托管平台\n创建仓库\r这里需要提前注册gitee帐号，并且实名，不然不能使用Git Pages服务，点击此处前往注册。\n创建仓库时建议创建与自己帐号名一致的仓库名，这样在gitee可以获取到一个专有二级域名的网址，如我的用户名impressionyang创建一个同名的仓库之后开启Pages服务得到了一个https://impressionyang.gitee.io的二级域名，而不用使用子文件夹，比较好看。 点击右上角的+号内的创建仓库进行创建仓库\n进行信息填写之后按照自己的想法选择私有或者公开之后创建仓库，不要自行添加任何文件哦，比如README什么的。\n仓库创建完成后点击仓库资源右边的克隆/下载里面的复制按钮复制仓库地址，留作后用\n配置Hexo的deploy配置\r如果需要配置Git Pages的话需要配置一下Hexo的_config.yml里面的deploy项，但在此之前，必须要先安装deploy插件，插件安装命令如下：\n1cnpm install hexo-deployer-git --save 接着进行配置，大概配置如下\n1deploy: 2 type: git 3 repo: 你的仓库地址 4 branch: master 注意：冒号后面一定要有空格\n配置好之后就可以进行上传部署了，在Hexo博客根目录下面运行\n1hexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo d 然后hexo就会进行资源文件的清理、生成、部署到git上，部署时根据你的git的验证方式进行即可\nimpressionyang","date":"March 9, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/hexo-init-config-1/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"hexo","url":"/tags/hexo/"}],"timestamp":1583772298,"title":"Hexo + Git Pages搭建个人博客（一）"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"psifidotos 的 applet-window 系列完全实现unity当年风采\r熟悉我对Linux桌面态度的人都知道我个人是很推崇当年Ubuntu的Unity桌面的全局菜单的整合功能的，其有着能把窗口标题栏以及窗口按钮和全局菜单整合为一体的功能，能够大大节省屏幕的纵向空间而不影响使用菜单以及查看窗口标题和使用窗口按钮。在我个人看来，Ubuntu的Unity桌面简直就是Linux桌面环境的最强代表，直到它退出历史舞台。\n至今我仍然向往那种能够有效率节省屏幕空间的功能却苦于没有什么桌面能够原生支持，但是，在我转向了archlinux+KDE之后便发现了此事有所转机。\n一开始我是使用KDE的一个名为active window control的插件进行使用，它能够将窗口标题栏和顶栏进行结合，但是全局菜单需要使用KDE的原生全局菜单插件，并且其使用起来并不是很友好，不过它也能够在一定程度上节省了屏幕的纵向空间，所以也能够勉强够用，但是使用起来并不是很开心。\n但是在KDE桌面的强大的可定制化插件的支持下，由psifidotos所编写的applet-window系列插件能够配合Plasma KDE桌面来完美来达成‘这一愿想。\n要实现Unity桌面的功能需要安装他写的三个插件：\napplet-window-title applet-window-buttons applet-window-appmenu 说明：archlinux+KDE（原理上来说manjaro+KDE也可以）在安装好桌面后还需要安装cmake和extra-cmake-modules，一般在安装了这两个编译依赖之后如果还是编译不成功请在评论区说明清楚哦。\n安装并配置三个插件\rapplet-window-title\rgithub地址点击此处\n克隆仓库\n1git clone https://github.com/psifidotos/applet-window-title.git 由于此插件使用QML编写，所以可以直接使用命令装入插件\n1cd applet-window-title 2plasmapkg2 -i . 图示 至此applet-window-title安装完毕\napplet-window-buttons\rgithub地址点击此处\n克隆仓库\n1git clone https://github.com/psifidotos/applet-window-buttons.git 因为该插件使用C++进行编写，所以需要进行编译安装\n1cd applet-window-buttons 2sh install.sh 图示 基本上如果没有编译依赖缺失的话可以一路编译下去然后自动安装\n至此applet-window-buttons安装完毕\napplet-window-appmenu\rgithub地址点击此处\n克隆仓库\n1git clone https://github.com/psifidotos/applet-window-appmenu.git 同样因为该插件使用C++进行编写，所以需要进行编译安装\n1cd applet-window-appmenu 2sh install.sh 图示 基本上如果没有编译依赖缺失的话也是可以一路编译下去然后自动安装\n至此applet-window-appmenu安装完毕\n配置\rapplet-window-title applet-window-buttons applet-window-appmenu 后记\r现在基本上已经能够得到和Unity桌面那样的机制体验了，舒服。\nimpressionyang","date":"February 29, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/unity-style-applet/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Plasma","url":"/tags/plasma/"},{"title":"plasma-applet","url":"/tags/plasma-applet/"}],"timestamp":1583003390,"title":"KDE下完美的Unity桌面体验，扔掉active Window Control"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"自动初始化Linux下Qt通用开发的CMake GUI工程的脚本\r这个脚本的来由是在我使用了CMake作为Qt工程的编译工具之后，为了使得即使在没有qtcreator的情况下也能快速地建立CMake Qt GUI工程从而使用其他的文本编辑器如VSCode或者Atom进行开发，而开发的工程建立脚本。 本项目已经发布至我的github 完成的功能\r自动构建一个标准的CMake Qt GUI工程 使用了以前的通用懒人CMake模板文件 可以自定义工程名称 从github克隆至本地即可重复使用 脚本\r脚本构建的标准项目目录\r1ProjectName #项目目录 2├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 3└── src #源码目录 4 ├──utilities #次级原码目录 5 | ├── CMakeLists.txt #次级源码目录CMakeLists.txt配置文件 6 | ├── util.h #其他次级源码 7 | └── util.cpp #其他次级源码 8 ├── CMakeLists.txt #源码目录CMakeLists.txt配置文件 9 ├── main.cpp #程序入口 10 ├── ... #其他项目文件 11 └── test.cpp #其他项目文件 脚本内容\r1#! /bin/bash 2 3#create by impressionyang on 2020/01/05 4 5echo \u0026#34;start setting up your own project\u0026#34; 6 7read -p \u0026#34;please input your project name:\u0026#34; project_name 8read -p \u0026#34;please input your runable file\u0026#39;s name:\u0026#34; file_name 9 10cp -r cmaketest $project_name 11 12sed -i \u0026#34;s/cmaketest/$project_name/g\u0026#34; $project_name/CMakeLists.txt 13sed -i \u0026#34;s/cmaketest/$file_name/g\u0026#34; $project_name/src/CMakeLists.txt 14 15 16 17echo \u0026#34;project setup finish, please copy your project to your workspace and enjoy your development!\u0026#34; 脚本原理\r脚本同级目录下有一个标准的项目工作目录，此目录是为了提供一个标准的工程项目模板而存在的，结构如上述脚本构建的标准项目目录。而脚本的工作原理就是通过读入你设置的工程名和可执行文件名之后复制一份标准工程目录然后通过字符串定位修改相应值从而产生一个新的通用编辑器的工程了。\n使用\r克隆项目至本地\n1git clone https://github.com/impressionyang/qt_cmanke_project_initialize.git 运行setup.sh文件并设置项目名和可执行文件名（使用英文！！！）\n1sudo chmod +x setup.sh 2 3./setup 将当前新生成的项目目录拷贝至你的工作目录下进行编程即可\nimpressionyang","date":"February 27, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/auto-init-cmake-qt-project/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"C","url":"/tags/c/"},{"title":"C++","url":"/tags/c++/"},{"title":"Qt","url":"/tags/qt/"}],"timestamp":1582796914,"title":"Qt CMake GUI项目生成脚本"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"终端美化\r终端是Linux用户的一大特色，对于经常使用终端的我来说，单调的配色和命令行已经使我有点审美疲劳了，配色可以使用首选项配置，但是命令行的模式我是有点犯尴尬症，所以重新配置了下终端并写了这篇帖子\nbash和powerlinepowerline 配置\rbash相信是很多接触Linux系统的人使用的最频繁的shell了，作为普遍使用的终端shell，bash也是可以进行美化的，美化方案就是powerline 安装\r安装 powerline及字体\n1sudo pacman -S powerline 2sudo pacman -S powerline-fonts 3sudo pacman -S powerline-vim 配置\rbashrc 配置（注意python版本），使用命令vim ~/.bashrc ，并将以下内容加入文件中\n1# powerline 2 3powerline-daemon -q 4POWERLINE_BASH_CONTINUATION=1 5POWERLINE_BASH_SELECT=1 6. /usr/lib/python3.7/site-packages/powerline/bindings/bash/powerline.sh 应用:\n1source ~/.bashrc 效果\rzsh和oh-my-zsh\r虽然在bash下有了powerline这一主题，但是经过了解还有一个zsh支持更多的美化主题，特别是使用了oh-my-zsh插件后还有更多的功能，以下是安装及配置方法\n安装\r安装 zsh\r1sudo pacman -S zsh 安装 oh-my-zsh\r三个选一个\n1sh -c \u0026#34;$wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)” 2 3或 4wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh 5sh install.sh 6或 7https://github.com/robbyrussell/oh-my-zsh/archive/master.zip 查看相关命令\r查看已有的shell\n1cat /etc/shells 查看当前shell\n1echo $SHELL 替换shell\r使用zsh替换bash（重新打开终端生效）\n1chsh -s /bin/zsh 还原bash（需要重启）\n1chsh -s /bin/bash 查看zsh版本\n1zsh --version 语法高亮\rhttps://github.com/zsh-users/zsh-syntax-highlighting 因为使用了 oh-my-zsh 故安装简单很多直接 1$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 然后在 ~/.zshrc 中加入插件 1plugins=( 2 zsh-syntax-highlighting 3) 效果\rimpressionyang","date":"February 25, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/console-beautify-config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"console，shell","url":"/tags/consoleshell/"}],"timestamp":1582668100,"title":"终端shell美化"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"GoldenDict个人配置\r\u0026ndash;一款支持Linux的强大单词翻译软件\n以下来自百度百科 GoldenDict 是一款不错的、与StarDict（星际译王）类似的词典软件。它使用 WebKit作为渲染核心，格式化、颜色、图像、链接等支持一应俱全；支持多种词典文件格式，包括Babylon的 .BGL 文件、StarDict 的 .ifo/.dict/.idx/.syn 文件、Dictd的·index/.dict(.dz) 文件、ABBYY Lingvo 的 .dsl/.lsa/.dat 文件。\n安装\r1sudo pacman -S goldendict 配置\r安装之后会发现基本上GoldenDict是基本上用不了的，因为词典匮乏，基本上差不了太多的单词，这是就需要进行相关的词典配置了； GoldenDict支持本地离线词典和在线词典两种查询方式 离线词典\r不知道去哪里下载离线词典的可以点击此处去本人找到的这一个网站去下载，这其实是星际译王的词库网站，恰好GoldenDict支持这一种词典格式。 下载相应词典之后将文件解压至某一个合适的文件夹并且记住文件夹的路径。\n然后在编辑-\u0026gt;词典-\u0026gt;词典来源-\u0026gt;文件中添加一个文件路径，就填写刚才解压到的文件夹的目录，然后勾选递归搜索，以便以后加入新词典的时候能查找到，新加入词典后点击右下角的重新扫描即可。\n在线翻译源\r在线翻译的话推荐使用 有道和 必应，其翻译使用地址如下 有道：\n1http://dict.youdao.com/search?q=%GDWORD%\u0026amp;ue=utf8 必应：\n1https://cn.bing.com/dict/search?q=%GDWORD% 同样的，在编辑-\u0026gt;词典-\u0026gt;词典来源-\u0026gt;网站中，添加一个一个网址，将上述信息填入，并且将其他用不了的地址的启用取消。\n后记\r好了，现在已经是安装并且配置好了，在使用的时候自己在首选项配置好之后就可以使用主界面或者划词器进行翻译单词了。\nimpressionyang","date":"February 25, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/goldendict-personal-config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"goldendict","url":"/tags/goldendict/"}],"timestamp":1582628792,"title":"GoldenDict个人配置"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"markdown数学公式\r此贴用来记录日常使用的markdown数学公式以供参考 不定时更新 本文所用的公式渲染器是KaTeX，相关语法支持请点击此处查看 行内或独立公式语法\r行内公式\r将公式插入到文本内 符号: $公式内容$ 例子: (要表示)公式x+y表示 -\u0026gt; (形式)公式$x+y$ -\u0026gt; (结果)公式\n$x+y$ 独立公式\r数学公式独占一行且居中 符号: $$公式内容$$ 例子: (要表示)x+y -\u0026gt;(形式)$$x+y$$ -\u0026gt; (结果): $$x+y$$\n运算法则一般公式举例\r四则运算\r加法，符号：+，表示：$x+y=z$，结果：$x+y=z$ 减法，符号：-，表示：$x+y=z$，结果：$x-y=z$ 乘法，符号：\\times，表示：$x \\times y=z$，结果：$x \\times y=z$ 除法，符号：\\div，表示：$x \\div y=z$，结果：$x \\div y=z$ 四则运算扩展\r加减法，符号：\\pm，表示：$x \\pm y=z$，结果：$x \\pm y=z$ 减加法，符号：\\mp，表示：$x \\mp y=z$，结果：$x \\mp y=z$ 点乘法，符号：\\cdot，表示：$x \\cdot y=z$，结果：$x \\cdot y=z$ 星乘法，符号：\\ast，表示：$x \\ast y=z$，结果：$x \\ast y=z$ 斜除法，符号：/，表示：$x/y=z$，结果：$x/y=z$ 绝对值，符号：||，表示：$|a+b|$，结果：$|a+b|$ 分式，符号：\\frac{分子}{分母}，表示：$\\frac{x+y}{y+z}$，结果：$\\frac{x+y}{y+z}$ impressionyang","date":"February 25, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/markdown-math-support/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"markdown","url":"/tags/markdown/"}],"timestamp":1582623630,"title":"Markdown数学公式"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"Makfile文件的编写\r不定期更新 make和Makefile\r以下来自百度百科 make:\nmake是一条计算机指令，是在安装有GNU Make的计算机上的可执行指令。该指令是读入一个名为makefile 的文件，然后执行这个文件中指定的指令。有时make又指GNU Make，GNU Make 是一个用来控制可执行文件和其他一些从源文件来的非源代码文件版本的软件。\nMakefile:\n一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，也可以执行操作系统的命令。\nMakefile编写\r以下是本人自己比较喜欢用的Makefile的使用方式的总结，一般为单个项目产生单个可执行文件，一般是控制台程序或者opencv相关 简单的多文件的C/C++控制台程序\r文件目录是：\n1ProjectName #项目目录 2├── Makefile #项目根目录Makefile配置文件 3├── main.c #mian方法，include了stack.h 4├── stack.h #站结构定义 5└── stack.c #栈方法实现 Makefile文件内容总览\r1object = main.o stack.o 2 3main : $(object) 4 gcc -o main $(object) 5 6main.o : main.c 7stack.o : stack.h stack.c 8 9.PHONY : clean 10clean: 11 rm $(object) 注意: 如果是编译C++的项目就需要在main生成的命令里面把gcc编译程序换成g++ 解释\r上述是我的C/C++多文件编译一般使用的Makefile编写风格，因为没有特殊的中间文件操作，所以都是用的make的自动规则，下面解释上面Makefile内容，基本上可以分成4部分：\n在此之前，先说明一下Makefile基本规则：\n基本上按照以下模板：\n1target ... : dependes ... 2 command 3 ... 目标(target)：目标顶格写，后面是冒号（冒号后面是依赖）。目标文件, 可以是 Object File, 也可以是可执行文件。\n依赖（dependes）： 依赖是用来产生目标（target）的目标文件。\n命令（command）：命令前面一定是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的动作（任意的shell命令）。\n接下来继续讲解\n一、目标及所有依赖定义\r这部分是为了定义包含的链接目标文件\n这部分对应的内容是\n1object = main.o stack.o 此处使用目标名object包含了main.o和stack.o中间文件，这两个文件需要在下一部分中声明其生成方式。\n二、声明目目标执行文件的生成方式\r这部分是为了生成最终的可执行文件\n这部分对应的内容是\n1main : $(object) 2 gcc -o main $(object) 此部分规定了最终的目标文件的生成规则\n三、声明依赖的目标文件生成\r这部分是声明所有依赖的文件的生成方式，使用了make的默认生成规则,语法是 目标文件: 依赖的头文件和源文件\n这部分对应的内容是\n1main.o : main.c 2stack.o : stack.h stack.c 对应生成的是object的所有依赖文件\n四、指定clean规则\r这一步其实可以省略，主要目的是制定一个清理生成的中间文件的选项\n这部分对应的内容是\n1.PHONY : clean 2clean: 3 rm $(object) .PHONY : clean是说明clean是一个伪目标文件，从而不会对clean使用目标文件的生成。\n该部分的主要内容就是rm $(object)这条命令，它会删除object的所有依赖的目标文件，如果存在的话。\n使用\r生成可执行文件 1make 清除中间文件 1make clean impressionyang","date":"February 24, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/makefile_personal_config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"tech","url":"/tags/tech/"},{"title":"C","url":"/tags/c/"},{"title":"C++","url":"/tags/c++/"},{"title":"tools","url":"/tags/tools/"}],"timestamp":1582545573,"title":"Makfile文件的编写"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"CMake编写总结\r不定期更新 CMake介绍\r以下来自百度百科 CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。\nCMake和make\r以下来自百度百科 “CMake”这个名字是“cross platform make”的缩写。虽然名字中含有“make”，但是CMake和Unix上常见的“make”系统是分开的，而且更为高阶。\nmake和CMake之间的关系是CMake 通过命令可以生成make执行的Makefile文件，所以说CMake 是make 的升级版的生成工具\nCMake文档\r点击此处到达CMake的在线文档页面。\n各种CMake编写\r以下收录的是本人自己的各种项目的CMakeLists.txt文件，以做参考 CMakeLists.txt一般使用格式\r1#set minimum compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set project name 5project(CMaketest) 6 7#set target app name 8set(TARGET_NAME test) 9 10 11... 12 13 14#genarate a app 15add_executable(${TARGET_NAME} 源文件 头文件) 简单C++项目编写CMakeLists.txt\r简单项目是指只有一个文件夹，并且所有项目文件都放在其中的项目，由于文件结构简单，直接使用一下内容即可将项目进行编译。 1ProjectName #项目目录 2├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 3├── main.cpp #程序入口 4├── ... #其他项目文件 5└── test.cpp #其他项目文件 在当前项目文件夹新建CMakeLists.txt文件，并输入以下内容 1#set minimum compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set project name 5project(CMaketest) 6 7#set target app name 8set(TARGET_NAME test) 9 10#use c++ 17 stander 11set(CMake_CXX_STANDERD 17) 12 13 14#set all resources files 15file(GLOB SOURCES \u0026#34;*.cpp\u0026#34;) 16file(GLOB HEADERS \u0026#34;*.h\u0026#34;) 17 18 19#genarate a app 20add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS}) **注意：**简单项目不推荐使用GLOB_RECURSE，因为他会遍历所有找到的文件夹以及他的子文件夹，容易造成把build目录扫描导致main函数重复定义的情况 完成后用CMake编译生成makefile，即可使用make命令进行项目的编译了\n复杂（多文件夹）C++项目写CMakeLists.txt\r复杂项目示例\r一般有较多文件的项目都是使用多文件夹进行管理项目源文件的，使用多个不同级目录下保存源文件的管理方式使用CMake生成makefile可以使用以下管理方式 1ProjectName #项目目录 2├── CMakeLists.txt #项目根目录CMakeLists.txt配置文件 3└── src #源码目录 4 ├──utilities #次级原码目录 5 | ├── CMakeLists.txt #次级源码目录CMakeLists.txt配置文件 6 | ├── util.h #其他次级源码 7 | ├── util.cpp #其他次级源码 8 | ├── ... #其他次级源码 9 | └── log.cpp #其他次级源码 10 | ... #其他次级原码目录 11 ├── CMakeLists.txt #源码目录CMakeLists.txt配置文件 12 ├── main.cpp #程序入口 13 ├── ... #其他项目文件 14 └── test.cpp #其他项目文件 复杂项目的CMakeLists.txt\rCMakeLists.txt #项目根目录CMakeLists.txt配置文件 1#set minimum compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set project name 5project(CMaketest) 6 7#add the src subdirectory 8add_subdirectory(src) CMakeLists.txt\t#源码目录CMakeLists.txt配置文件 1#set minimum CMake compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set target app name 5set(TARGET_NAME testCMake) 6 7#use c++ 17 stander 8set(CMake_CXX_STANDERD 17) 9 10# add a source file subdirectory 11add_subdirectory(utilities) 12 13#set all resources files 14file(GLOB_RECURSE SOURCES \u0026#34;*.cpp\u0026#34;) 15file(GLOB_RECURSE HEADERS \u0026#34;*.h\u0026#34;) 16 17 18#genarate a app 19add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS}) CMakeLists.txt\t#次级源码目录CMakeLists.txt配置文件 其他次级原码目录CMakeLists.txt配置文件一样 可以不配置，因为使用了源码目录的CMakeLists.txt使用了GLOB_RECURSE，正常情况会自动遍历到此文件夹下 1#set minimum compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set all resources files 5file(GLOB_RECURSE SOURCES \u0026#34;*.cpp\u0026#34;) 6file(GLOB_RECURSE HEADERS \u0026#34;*.h\u0026#34;) 这样就可以对多个文件夹管理的项目使用CMake生成makefile了 qt项目编写CMake\rqt项目需要添加相应的库，只需要将一些配置项添加在源码目录CMakeLists.txt配置文件即可 1#set minimum CMake compile version 2CMake_minimum_required(VERSION 3.14) 3 4#set target app name 5set(TARGET_NAME testCMake) 6 7#use c++ 17 stander 8set(CMake_CXX_STANDERD 17) 9set(CMake_CXX_STANDARD_REQUIRED ON) 10 11#include this priject on 12set(CMake_INCLUDE_CURRENT_DIR ON) 13 14#auto genarate ui.h file 15set(CMake_AUTOUIC ON) 16 17#auto genarete moc file 18set(CMake_AUTOMOC ON) 19 20#auto genarate .qrc file on 21set(CMake_AUTORCC ON) 22 23# set QT type 24set(QT Core Gui Widgets Network DBus Sql) 25 26#add package lib 27find_package(Qt5 REQUIRED ${QT}) 28 29# add a source file subdirectory 30#add_subdirectory(utilities) 31 32#set all resources files 33file(GLOB_RECURSE SOURCES \u0026#34;*.cpp\u0026#34;) 34file(GLOB_RECURSE HEADERS \u0026#34;*.h\u0026#34;) 35file(GLOB_RECURSE FORMS \u0026#34;*.ui\u0026#34;) 36file(GLOB_RECURSE RESOURCES \u0026#34;*.qrc\u0026#34;) 37 38 39#genarate a app 40add_executable(${TARGET_NAME} ${SOURCES} ${HEADERS} ${FORMS} ${RESOURCES}) 41 42#add QT5 dependes 43target_link_libraries(${TARGET_NAME} PRIVATE Qt5::Widgets) 使用\r在当前文件夹下使用一下命令可以生成Makefile：\n1cmake 但是，如此生成的话会产生很多中间文件，从而导致了当前文件夹的文件过多，再次编辑文件的时候会很难找到确切的文件的状况，这就是污染项目结构 所以，为了不污染项目环境，推荐使用以下命令来生成Makefile 1mkdir build 2cd build 3cmake .. impressionyang","date":"February 23, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/cmake-personal-config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"C","url":"/tags/c/"},{"title":"C++","url":"/tags/c++/"},{"title":"tools","url":"/tags/tools/"}],"timestamp":1582498042,"title":"CMake编写总结"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"archlinux安装篇（二）\r接着上一次安装完成了之后应该能启动到archlinux的图形界面了，但是没有图形界面的话作为日常使用的系统还是很勉强的，所以还是很有必要进行接下来的图形操作界面的配置的\n接下来就是配置archlinux的图形操作环境了，本文介绍的是Plasma KDE桌面环境\n安装\r安装核显驱动\r以下的amd和intel核显驱动二选一，按照自己的具体情况来确定 1#amd 2sudo pacman -S xf86-video-ati 3#intel 4sudo pacman -S xf86-video-intel 安装显示管理器及登陆主题\r1sudo pacman -S sddm sddm-kcm 安装Plasma桌面和基本软件包加上Xorg\r1sudo pacman -S plasma-desktop xorg-server kdebase 现在基本上是已经安装好了图形界面环境了，可以使用命令startx进行测试 现在还不可以重启，还需要进行下一步的配置 配置\r虽然已经安装好了图形桌面环境，但是开机并不会进入到图形登录界面，因为相关的组件并没有启动，需要在安装好组建之后进行配置\n配置显示管理器开机自启 1sudo systemctl enable sddm 现在已经基本可以通过图形界面的方式登录到桌面环境了，接下来的其他配置就以后再讲\nimpressionyang","date":"February 22, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/archlinux-install_2/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"install","url":"/tags/install/"}],"timestamp":1582389499,"title":"Archlinux安装篇（二） KDE桌面环境"},{"authors":[],"categories":[{"title":"coding","url":"/categories/coding/"}],"content":"盘点C/C++语言编程+编译工具\r本帖子盘点了Linux下的各种C/C++的编程+编译工具及IDE（集成开发环境\n主要是收集Arch Linux下的 目录\rvim+gcc/g++ VSCode Code::Blocks QtCreator Clion Eclipse 各软件配置\r注意的一点是C的源文件是.c，C++的源文件是.cpp 本文只介绍了单文件的编译运行，多文件共同编译运行以后再讲 vim+gcc/g++\r安装\r1sudo pacman -S vim gcc 使用\rvim编写程序\r使用vim 源文件.c或者vim 源文件.cpp来打开C/C++文件 进入vim后使用i进入插入模式 编程完成后按Esc后进入命令模式后输入:wq进行保存退出 gcc/g++编译程序\rC使用命令gcc 源文件名.c -o 源文件名来生成可执行文件，C++使用命令g++ 源文件名.cpp -o 源文件名来生成可执行文件。\n编译程序其实也可以用make命令，但是这个设计后面的多文件编译，以后在介绍 运行程序\r使用上面gcc或者g++命令生成可执行文件后在当前可执行文件目录下使用./可执行文件名即可运行程序。\nVSCode\r安装\r推荐配置好archlinuxcn源之后安装其visual-studio-code-bin。 1sudo pacman -S visual-studio-code-bin 插件配置\r推荐安装下列插件 编程及运行\r新建文件并命名为.c或者.cpp文件 编程 点击右上角运行图标运行 Code::Blocks\r安装\r1sudo pacman -S qtcreator qt5 2sudo pacman -S codeblocks 配置控制台\r需要在settings-\u0026gt;enviromment-\u0026gt;Terminal to luanch console program中设置为自己需要使用的终端。 编程运行\r打开或者新建一个C/C++的源文件 编程 点击编译运行图标编译运行程序 QtCreator\r安装\r1sudo pacman -S qtcreator qt5 编程运行\r新建一个C或者C++工程 编程 点击右下角运行按钮运行程序 可能需要配置的问题：程序没有在终端中运行，而是在qtcreator内，当然，如果你不介意也无需在配置\n只需要在项目-\u0026gt;run-\u0026gt;run in terminal勾选即可\nClion\r安装\r1sudo pacman -S clion 编程\r新建C或者C++工程 编程 点击run Eclipse\r安装\r1sudo pacman -S eclipse 也可以去官网下载安装可执行二进制软件包，无安装，直接运行 配置插件\r需要安装CDT插件以使得Eclipse可以支持C/C++ 编程运行\r新建C/C++工程 编程 build 运行 没有运行实例哦，傻眼了吧，这玩意安装是很不方便的，所以我并不推荐，但是eclipse cdt基本上就是按照上述步骤运行的，所以加油。 impressionyang","date":"February 21, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/coding/c-cpp-tools-collect/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"program","url":"/tags/program/"},{"title":"C","url":"/tags/c/"},{"title":"C++","url":"/tags/c++/"},{"title":"tools","url":"/tags/tools/"}],"timestamp":1582281633,"title":"盘点C/C++语言编程+编译工具"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"Plasma顶栏和窗口标题整合插件\rActive Window Controle 窗口集成功能 Active Window Controle经过配置可以使得你的Plasma的窗口与顶栏相结合，达到Ubuntu曾经使用的Unity桌面环境那般高效，可以在全屏是节省一条标题栏的高度，毕竟显示器区域真的是寸土寸金的呀。\n安装\r此插件在archlinuxcn源中有：\n1sudo pacman -S plasma5-applets-active-window-control-git 也可以使用系统自带安装器搜索安装，但是不推荐在KDE Store上下载安装，因为在KDE Store上安装自行编译需要一定的编程功底，而且还容易因为编译依赖及系统环境的因素而无法编译成功。 配置\r安装完成后外观和按钮使用如下配置，窗口按钮路径就是个人文件夹下的aurorae下，其他的看个人，就可以达成Unity桌面的效果。 impressionyang","date":"February 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/active_window_control/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Plasma","url":"/tags/plasma/"},{"title":"plasma-applet","url":"/tags/plasma-applet/"}],"timestamp":1582211411,"title":"Plasma顶栏和窗口标题整合插件"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"一个命令进行Plasma热重启\r通过一个命令来重启Plasma桌面来释放系统资源 KDE Plasma桌面环境具有很多炫酷的显示效果，但是经过一天下来长时间使用Plasma桌面而不待机或者睡眠的话，Plasma桌面会占用大量的内存资源，为了解决这个问题，特地写了一个脚本文件来对Plasma桌面进行热重启，从而释放一些资源的占用\n思路基本上就是使用Plasma的指令先关闭Plasma桌面再启动它\n脚本文件内容\r具体内容：\n1#! /bin/bash 2kquitapp5 plasmashell \u0026amp;\u0026amp; kstart5 plasmashell 命名：restart_kde，注意，没有后缀名 赋权\r使用文本工具或者vim进行编写，编写完成后对其进行运行权限的赋权：\n1sudo chmod +x restart_kde 复制至bin文件夹\r将脚本文件移至path中指定的系统变量路径，可放至/usr/local/sbin、/usr/local/bin，/usr/bin中。\n移动命令：\n1sudo cp restart_kde /usr/bin 使用方法\r用KRunner，Alt+Space唤醒，确保KRunner拥有执行命令的功能 输入restart_kde即可 impressionyang","date":"February 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/restart_kde/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"Plasma","url":"/tags/plasma/"}],"timestamp":1582208201,"title":"一个命令进行Plasma热重启"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"wine和deepinwine的相关配置\r安装wine\r1sudo pacman -S wine wine-mono wine-gecko 配置\r字体\r可以通过更改注册表的方式更改wine调用的字体\n注册表文件内容：zh.reg\n内容大概就是把wine调用的windows自体改成Linux安装好的字体，可以自行修改自己想要的字体文件，我这里是全部替换成文泉驿字体的雅黑字体了\n1REGEDIT4 2[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] 3\u0026#34;Lucida Sans Unicode\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 4\u0026#34;Microsoft Sans Serif\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 5\u0026#34;Microsoft YaHei\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 6\u0026#34;微软雅黑\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 7\u0026#34;MS Sans Serif\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 8\u0026#34;Tahoma\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 9\u0026#34;Tahoma Bold\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 10\u0026#34;SimSun\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 11\u0026#34;Arial\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 12\u0026#34;Arial Black\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 13\u0026#34;宋体\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 14\u0026#34;新細明體\u0026#34;=\u0026#34;wqy-microhei.ttc\u0026#34; 打开注册表控制面板\n1wine regedit 然后选择导入注册表文件，选择刚才的zh.reg文件即可 DPI\r发现有字体显示过小的问题可以调整wine的DPI设置 打开wine配置面板\n1WINEARCH=win32 WINEPREFIX=~/.wine winecfg deepin-wine配置面板\rTIM 1env WINEPREFIX=\u0026#34;$HOME/.deepinwine/Deepin-TIM\u0026#34; winecfg deepin-wine无法启动应用\r解决方法来自B站up：等我稍后补充昵称 主要思路：可能是deepin-wine在打包时无意间加入了gnome依赖。所以补齐依赖就可以了。\n方法很简单，安装gnome-settings-daemon,安装代码：sudo pacman -S gnome-settings-daemon\n之后，将/etc/xdg/autostart/org.gnome.SettingsDaemon.XSettings.desktop 复制到 ～/.config/autostart/\n最后，去往设置—开机和关机—自动启动 中，将org.gnome.SettingsDaemon.XSettings.desktop的一项勾选启动即可。\nimpressionyang","date":"February 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/wine_deepinwine_config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"wine","url":"/tags/wine/"},{"title":"deepin","url":"/tags/deepin/"}],"timestamp":1582207281,"title":"Wine和deepinwine的相关配置"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"archlinux安装与应急使用双用U盘\r本次方案建议使用16G及以上的U盘进行安装，以保证得到较好的体验 建议使用USB3.0及以上的U盘，当然2.0也没问题，如果不使用图形界面的话 本次是在linux环境下完成的，当然Windows下也可以实现 使用意义\r在使用archlinux启动盘之前需要用dd命令将U盘刻为启动盘，这样就导致整个U盘分区被dd修改，最明显的是第一个装有安装环境的分区被分配了一个iso9960标志并且使用cfdisk打开该设备是会有提示使用写命令是会丢失丢失该标志从而导致标签异常使得启动异常，而安装环境仅有600+M，白白浪费了该启动盘的其他空间，因为不可以新建分区。\n另一方面，对于某些情况下，例如电脑的系统炸了，但是又要很快地进行某些工作的时候，例如运维、出差是别的电脑是win系统等情况时，需要尽快的使用linux操作系统的时候，如果有一个装在U盘里面的移动的linux操作系统就可以解决燃眉之急了，并且，在日常使用的时候也可以偶尔使用U盘里面的linux系统\n一些想体验linux操作系统又怕把自己的电脑搞坏的人也可以使用这一方案进行双系统使用，而不是去使用linux live环境。\n所以，在以上的需求之下，这一使用方案就从我的脑子应运而生了。\n基本想法\r主要实现的基本想法就是通过将刻好的启动盘的内容复制出来后在重新格式化U盘重新分区并尽量将前两个分区模仿原有的启动盘方案，然后剩下的分区在重新利用。\n，使用gparted或者blkid（Windows可以使用分区工具查看）查看U盘经过dd刻录之后的文件系统和标签。\n之后使用mount命令将其第一和第二个分区挂载后将其内容复制出来\n准备阶段\rUSB移动U盘或者移动硬盘一个 archlinux安装镜像一个 virtualbox等虚拟机或者是使用实体机一台 开始配置\r刻录启动盘\r首先下载archlinux的iso镜像，然后使用dd命令刻录一个启动U盘。\narchlinux镜像下载地址(清华https) 1sudo dd if=/path/to/archlinux/iso of=/path/to/your/Udisk /path/to/archlinux/iso是iso镜像路径 /path/to/your/Udisk是要刻录的U盘，注意是整个U盘的设备，不要加上分区号！ bs即block size可以直接用默认的 Windows下\rwindows系统下可以使用rufus的dd刻录 挂载复制分区内容\r本步骤目的是把启动盘安装环境分区内容和EFI分区内容复制出来 复制安装环境分区内容目的是让新分区后U盘重设标签后内容能够保持正确 复制EFI分区内容是因为dd默认刻录的时候分配的EFI太小了，只有64MB，而启动盘原有的启动内容本身就已经占用了45MB了，为了保证能够让新安装的linux共享的EFI分区能够有足够的空间，取药新分出一个500MB的EFI分区。 Windows下如果无法访问的话推荐使用虚拟机直接读取archlinux镜像进入安装环境使用纯命令行进行操作 先复制第一分区（安装环境分区） 1#sdXY是U盘设备的第一个分区号 2sudo mount /dev/sdXY /mnt 3 4#下面步骤可以用文件管理器代替 5cp -r /mnt path/to/save/files 6umount -R /mnt 在复制第二分区（EFI分区） 1#sdXY是U盘设备的第二个分区号 2sudo mount /dev/sdXY /mnt 3 4#下面步骤可以用文件管理器代替 5cp -r /mnt path/to/save/files 6umount -R /mnt 重新分区U盘\r推荐使用形化操作的软件进行，linux下推荐使用gparted,Windows下推荐Disk Ginuns 将分区分为msdos格式，也就是MBR，划分出700M，500M，以及剩下空间的三个分区 将700M的分区格式化为fat32,卷标为ARCH_日期年月(如果是2020年2月的话就是ARCH_202002) 将500M分区格式化为fat32,卷标为ARCHISO_EFI。 剩下的那个分区格式化为ext4,也可以不管，在安装linux系统的时候在用，也可以格式化为其他的分区格式作为他用，但是本文是用来安装linux的。 示例\n恢复安装盘的个分区内容\r再次使用挂载命令将分区挂载，然后将对应的分区内容回复就行，需要注意的是，安装环境的分区卷标是ARCH_日期年月的，启动分区的卷标是ARCHISO_EFI的，不要恢复错误。\n安装archlinux\r安装archlinux至新分区中，参考文章archlinux安装篇 新系统最好使用bootctl impressionyang","date":"February 20, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/usb_boot_multi_use/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"USB","url":"/tags/usb/"}],"timestamp":1582200190,"title":"Archlinux安装与应急使用双用U盘"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"arch系的bumblebee安装\rbumblebee有什么用\rbumblebee是用来进行双显卡切换的工具，专用于具有NVDIA独立显卡以及CPU核显双显卡方案的笔记本来说可以有效的节约电源 有效地进行双显卡的快速切换使用，默认使用核显以节约电量 安装bumblebee\r安装依赖\r1sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus 安装bumblebee\rarchlinux 1sudo pacman -S bumblebee mesa lib32-virtualgl lib32-nvidia-utils manjaro 使用自带的硬件管理工具 1sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee 允许服务\r1sudo systemctl enable bumblebeed 添加用户组并重启\r将$USER替换为自己的用户名 1sudo gpasswd -a $USER bumblebee 2sudo reboot 测试bumblebee\r1optirun glxgears 通过关闭vblank来解锁刷新率 1vblank_mode=0 optirun glxspheres 如果帧数还是有问题就是依赖未满足了 设置NVIDIA\r1optirun -b none nvidia-settings -c :8 wine支持\r1optirun wine application.exe steam支持\r在steam游戏的启动选项中添加如下 1primusrun %command% 有时optirun更稳定。 1 optirun %command% 在某些情况下，这些都不起作用（例如在Team Fortress 2中），所以可以使用： 1LD_PRELOAD=\u0026#34;libpthread.so.0 libGL.so.1\u0026#34; __GL_THREADED_OPTIMIZATIONS=1 optirun %command% 2 3vblank_mode=0 PRIMUS_SYNC=1 primusrun %command% 4 5vblank_mode=0 primusrun %command% impressionyang","date":"February 19, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/arch_sierial_bumblebee_install/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"Linux","url":"/tags/linux/"},{"title":"bumblebee","url":"/tags/bumblebee/"},{"title":"archlinux","url":"/tags/archlinux/"}],"timestamp":1582152326,"title":"Arch系的bumblebee安装"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"Linux控制台显示bilibili小电视\r不限制linux系统发行版、不限制shell 显示效果\r实现步骤\r1 制作bilibili小电视文本\r文本如下 1 2 // 3 \\\\ // 4 \\\\ // 5 ##DDDDDDDDDDDDDDDDDDDDDD## 6 ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ 7 ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ 8 ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ 9 ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ 10 ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ 11 ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ 12 ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| 13 ## MMMMMMMMMMMMMMMMMMMM ## 14 ##MMMMMMMMMMMMMMMMMMMMMM## welcome impressionyang 15 \\/ \\/ 文本来源,bilibili官网控制台输出 2 配置显示\r以下是使用bash进行配置的，对应的是.bashrc配置文件 如果使用别的shell，配置对应设置文件即可 将bilibili小电视文本文件（最好设为隐藏文件）放到个人目录下，与.bashrc同目录 在.bashrc中配置显示bilibili小电视文本文件即可，文末需添加的指令代码如下 1cat ～/.bilibili 2echo 加echo是为了换行，如果文本中已经换行可能就不用加了 impressionyang","date":"February 19, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/linux_show_bilibili/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"shell","url":"/tags/shell/"},{"title":"bash","url":"/tags/bash/"}],"timestamp":1582150363,"title":"Linux显示bilibili小电视"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"asciiview \u0026mdash;archlinux生成字符图片的程序\r控制台生成ascii字符图片的程序 安装\r在arch下需要安装的组件有aview aview是将特定的字符矩阵将图片以字符的形式显示出来的程序 asciiview通过调用特定的外部程序如imagemagick等从图片生成那个特定的矩阵序列，到后使用aview将矩阵通过字符的形式显示出来。 aview是在aur中进行维护的，所以要通过aur下载 1yay -S aview imagemagick 使用方法\r生成字符图片\r支持的图片为一般图片如jpg，png等 一般默认命令\n1asciiview 图片路径 -driver curses 支持的字体有：vga8 vga9 mda14 vga14 X8x13 X8x16 X8x13bold vgagl8 控制字体\n1asciiview 图片路径 -driver curses -font vga8 示例\n原图\n保存字符图片\r生成图片之后通过s键可以保存图片字符 按s键开始保存 保存为Text file 输入图片宽度和高度以及保存的文件名 选择字体 配置项选择好后按Leave this menu，提示是否保存文件，输入y 保存完毕，按q退出 显示 impressionyang","date":"February 19, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/archlinux_asciiview/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"picture","url":"/tags/picture/"},{"title":"Linux","url":"/tags/linux/"}],"timestamp":1582122980,"title":"Archlinux生成字符图片"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":" 本帖子是用来记录git的使用操作的，会在使用到新功能的时候进行更新，所以本贴是会进行较为长期的更新的\n基本命令\r初始化配置（$username、 $useremail替换为自己的）\r1git config --global user.name $username 2git config --global user.email $useremail 建库\r1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库\n1git init 2、把文件添加到版本库中\n1git add -A 3、用命令 git commit告诉Git\n1git commit -m \u0026#39;first\u0026#39; 4、关联到远程库\n1git remote add origin 你的远程库地址 2git remote add origin \u0026#39;https://git.oschina.net/s/vue.git\u0026#39; 5、获取远程库与本地同步合并\n1git pull origin master --allow-unrelated-histories 6、使用 git push命令\n1git push --set-upstream origin master 2 3git push -u origin master //github 使用了此条命令 Git冲突：commit your changes or stash them before you can merge（在合并之前提交或保存更改）\n利用stash 数据储存\ngit stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。 git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。 git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 提交\r11、git add .（后面有一个点，意思是将你本地所有修改了的文件添加到暂存区） 22、git commit -m \u0026#34;\u0026#34;(引号里面是你的介绍，就是你的这次的提交是什么内容，便于你以后查看，这个是将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中) 33、git pull origin master 这是下拉代码，将远程最新的代码先跟你本地的代码合并一下，如果确定远程没有更新，可以不用这个，最好是每次都执行以下，完成之后打开代码查看有没有冲突，并解决，如果有冲突解决完成以后再次执行1跟2的操作 44、git push origin master 将代码推至远程就可以了 git 同步 本地文件\r提交更新\r1git add . 2git commit -m \u0026#39;内容\u0026#39; 3git pull origin master 4git push origin master 拉取到本地\r从零开始，在某空文件夹 1git init 2git remote add origin https://github.com/impressionyang/Markdown-Sync.git 3git pull origin master --allow-unrelated-histories 拉取更改后的更新 1git pull origin master ssh公钥配置\r一般来说，正常使用git的开始使用http方式获取的，向服务器提交时也是会用帐号密码的方式进行更新，虽然这样做安全系数会更高些，但是随之而来的会发现频繁更新文件提交时输入密码真的是太难受了，所以就有了这种使用ssh公钥配置的方式进行身份验证，减少了帐号密码输入的环节进行提交\n生成密钥\r如果进行了相关的ssh配置则能够看到如下显示 如果没有事先配置，需要进行ssh密钥的生成，前提是已经设置好了邮箱和用户，命令如下： 1ssh-keygen -t rsa 配置过程中直接回车3次，第一次是生成密钥文件名,第二次和第三次则是设置密钥的密码，如果不设置密码就直接回车即可，配置好之后即可看到上面图片红框的内容\n配置服务器\r以github为例，当你生成好密钥之后，能够看到有一个.pub文件，这个叫做公钥，使用cat ~/.ssh/id_rsa.pub命令来查看公钥的内容，将其配置到你的github中的个人配置里面，使用ssh方式获取仓库即可\n点击右上角个人图标后弹出的列表中点击settings 点击左侧列表的SSH and PGP keys 点击右上放绿色的New SSH key,输入生成的SSH公钥 impressionyang","date":"February 19, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/git_use_guid/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"git","url":"/tags/git/"}],"timestamp":1582122767,"title":"Git使用要点"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"先导\r安装ArchLinux\n分区并挂载\r分区：\rfdisk -l 查看要安装硬盘符/dev/sdX X代表的是第几个硬盘\ncfdisk /dev/sdX 分区工具分区\n分区规范uefi\r必须要有esp（efi）分区，即 EFI system\n必须要有根分区/\n可选：\nswap分区（内存小需要，RAM\u0026gt;8G就不用了） /home分区（个人文件夹，单独分区以便系统炸了不影响个人数据） 挂载：\r1.必须\n1#此/dev/sdXY为根分区 2 mount /dev/sdXY /mnt 3 mkdir /mnt/boot 4#此/dev/sdXY为EFI分区 5 mount /dev/sdXY /mnt/boot sdXY的X和Y是指存储设备的驱动号，有一些nvme硬盘是显示nvmeXnYpZ,X、Y、Z也是指nvme硬盘驱动号，请使用fdisk -l来查看 2.应用了可选分区的\n1 mkdir /mnt/home 2 #此/dev/sdXY为/home分区 3 mount /dev/sdXY /mnt/home 4 swapon /dev/sdXY #交换分区 安装配置系统\r安装基本系统\r准备\r1 ping -c 3 baidu.com 检查联网 2 vim /etc/pacman.d/mirrorlist (将合适源放到开头) 3 timedatectl set-ntp true 安装基本系统及相关软件\r1 pacstrap /mnt base base-devel linux linux-firmware sudo networkmanager netctl dialog dhcpcd dhcp wpa_supplicant vim base base-devel ：主要系统 linux linux-firmware ：linux内核相关 sudo ：超级用户提权工具 networkmanager ：网络管理器 netctl dialog ：无线网络连接工具 dhcpcd dhcp wpa_supplicant : 自动设置ip地址相关 vim : 文本编辑器，base中不再提供，需自行安装 配置系统\r1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 2 3 arch-chroot /mnt 4 5 visudo 6 #注{将root ALL=(ALL) ALL 下面的 %wheel ALL=(ALL) ALL的注释去掉--》允许wheel整个组里的所有用户有权限用sudo} 7 8 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 9 #设置系统时区 10 11 hwclock --systohc --utc 12 #设置时间标准 为 UTC，并调整 时间漂移: 13 14 vim /etc/locale.gen 15 #移除对应行前面的注释符号（＃）即可，建议选择帶UTF-8的項{建议移除注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF -8 zh_TW.UTF-8 UTF-8} 16 17 locale-gen 18 #生成locale讯息 19 20 echo “LANG=en_US.UTF-8” \u0026gt; /etc/locale.conf 21 #将系统 locale 设置为en_US.UTF-8 22 23 echo “myhostname” \u0026gt; /etc/hostname 24 #设置myhostname为主机名 25 26 systemctl enable NetworkManager 27 systemctl enable netctl 28 #配置网络管理器自动启动 29 30 useradd -m -g users -G wheel username 31 #设置username为用户名 32 33 passwd 34 #为root设置密码 35 36 passwd username 37 #为username设置密码 配置引导程序（二选一，推荐bootctl）\rbootctl\rbootctl是arch系列中systemd就提供的功能，能够简单快速的创建启动项，缺点是界面过于单调 1 bootctl install --path=/boot 2 vim /boot/loader/loader.conf 并将内容设置为：\n1 #timeout 4 2 default arch 注：#timeout 4 可以保持注释状态 vim /boot/loader/entries/arch.conf 并将内容设置为： 1 linux /vmlinuz-linux 2 initrd /initramfs-linux.img 3 options root=PARTUUID=yourPARTUUID rw 注：yourPARTUUID为你的PARTUUID,可以用blkid -s PARTUUID -o value /dev/sdXY \u0026gt;\u0026gt; /boot/loader/entries/arch.conf来将你的PARTUUID添加到你的arch.conf中再编辑，其中sdXY为你的根分区 grub\rgrub提供了功能全面的启动菜单选项，拥有很多漂亮的主题界面，缺点是配置项太多 1pacman -S dosfstools grub efibootmgr 2grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=archlinux --recheck 3grub-mkconfig -o /boot/grub/grub.cfg 重启系统\r1exit 2umount -R /mnt 3reboot 到这里基本上重启就能进入到系统了，但是有时候会启动不成功，下面为一些注意事项，以便能够确保完成安装 安装完成后需要注意的事情\r/boot有时候因为一些原因（可能是自己粗心大意）导致EFI没挂载上去，或者挂载上去之后安装linux内核的时候没有安装一些重要文件至/boot文件夹则需要重新安装linux内核 解决：重新安装linux内核\n1#在超级用户下 2pacman -S linux linux-firmware impressionyang","date":"February 19, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/archlinux_install_1/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"install","url":"/tags/install/"}],"timestamp":1582111634,"title":"Archlinux安装篇（一） 基本系统"},{"authors":[],"categories":[{"title":"tech_and_skill","url":"/categories/tech_and_skill/"}],"content":"MANJARO KDE安装配置\r已换Arch Linux，Manjaro文章已经不再添加更新，此文为以前所写，作为备份用,看心情更新 安装\r制作启动盘\rWindows下\r使用rufus工具进行烧录即可。 Linux下\rlinux下推荐使用dd命令来进行安装，dd是一种按照文件单元进行复制的工具，可以用来进行备份，也可以用来进行刻录Linux启动盘，一般来说，近几年的图像界面的发行版里面都会安装有dd工具，命令提示如下： 1sudo dd if=read_in_file of=write_to_file bs=1M 提前说一下，在Linux中一切都是用文件来表示的，如在本例中的写入文件，一般来说是U盘，但是在Linux中他是已一个文件来表示的，一般为/dev/sda之类的\nif：读取文件的绝对路径\nof：写入文件的绝对路径\nbs：写入的缓冲区？\n安装\rBIOS关闭安全启动，推荐使用uEFI进行安装 进入安装环境\r初始界面 硬件信息配置\r选择时区 键盘设置 分区\r分区相关 配置用户\r配置用户信息 确认并安装\r安装完成后即可重启系统 配置\r系统项\r软件源\r官方软件源\rmanjaro官方给出了一个命令使得我们可以方便地更新我们的官方软件源，使用以下命令即可从官方服务器拉取相关源（能联网就可以做到）并测速，自己选择几个合适的源确定即可。 命令：\n1sudo pacman-mirrors -i -c Chaina -m rank ArchLinuxCN源\rArchLinuxCN是Arch中文组维护的一个软件合集，里面包含了一系列的中国人使用的软件，比如WPS、网易云音乐等。\n在/etc/pacman.conf文件中追加源即可\n以下代码为配置清华源\n1sudo vi /etc/pacman.conf 2 3# 然后在按下i 进入编辑 按Ctrl+Shift+v粘贴 4 5#粘贴内容 6[archlinuxcn] 7SigLevel = Optional TrustedOnly 8Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 9 10# 按下Esc后输入:wq 退出，更新源信息并倒入GPG Key 11 12sudo pacman -S archlinuxcn-keyring\u0026amp;\u0026amp;sudo pacman -Syy 如果懒得管理密钥之类的东西（经常会导致archlinuxcn的软件安装失败，说是验证问题的）就把archlinuxcn的软件信任等级从Optional TrustedOnly设为TrustAll，但是如果出现问题archlinuxcn将不负任何责任。 其他的archlinuxcn源（可自行替换）\r从官方那里拉取的 1## 2## Arch Linux CN community repository mirrorlist 3## Generated on 2019-10-01 4## 5 6## 中国科学技术大学 (ipv4, ipv6, http, https) 7#Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 8 9## 清华大学 (ipv4, ipv6, http, https) 10#Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 11 12## Our main server (ipv4, ipv6, http, https) 13#Server = https://repo.archlinuxcn.org/$arch 14 15## xTom (Hong Kong server) (Hong Kong) (ipv4, ipv6, http, https) 16#Server = https://mirror.xtom.com.hk/archlinuxcn/$arch 17 18## xTom (US server) (US) (ipv4, ipv6, http, https) 19#Server = https://mirror.xtom.com/archlinuxcn/$arch 20 21## Open Computing Facility, UC Berkeley (Berkeley, CA, United States) (ipv4, ipv6, http, https) 22#Server = https://mirrors.ocf.berkeley.edu/archlinuxcn/$arch 23 24## 网易 (ipv4, http, https) 25#Server = https://mirrors.163.com/archlinux-cn/$arch 26 27## xTom (Netherlands server) (Netherlands) (ipv4, http, https) 28#Server = https://mirror.xtom.nl/archlinuxcn/$arch 29 30## SJTUG 软件源镜像服务 (ipv4, https) 31#Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/$arch 32 33## 腾讯云 (ipv4, https) 34#Server = https://mirrors.cloud.tencent.com/archlinuxcn/$arch antergos源\r貌似这玩意儿废弃了？ aur源\rAUR是Arch User Repository（Arch用户软件源），包含了一些不被官方源收录的软件，还有很多个人开发者开发的超酷的软件等你下载，但是aur不归pacman管理，所以要使用其他的包管理软件，如yay，yaourt(已停止维护)等。\n设置 aur 源\n修改 /etc/yaourtrc，去掉 # AURURL 的注释，修改为\n1AURURL=\u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; iBus拼音输入法\r为什么用iBUs？\niBUs支持使用与KDE Plasma相近的输入法面板主题，使用iBus输入法可以让输入法和系统主题更有统一感。 安装\r安装iBus 1sudo pacman -S ibus 安装iBus拼音输入法 1sudo pacman -S ibus-sunpinyin 2#这个输入法我个人比较喜欢，也可以安装google的拼音输入法 安装iBus Qt支持 1yay -S ibus-qt 配置iBus 需要在~/.bashrc下添加 1export GTK_IM_MODULE=ibus 2export XMODIFIERS=@im=ibus 3export QT_IM_MODULE=ibus 在~/.xprofile和~/.xinitrc文末后添加 1export GTK_IM_MODULE=ibus 2export XMODIFIERS=@im=ibus 3export QT_IM_MODULE=ibus 4ibus-daemon -drx 启动iBus Deamon守护进程 控制台输入 1ibus-setup 之后自己进行输入法的配置就行 配置输入法面板的主题\r输入法面板的主题需要在可见面板中添加一个小部件输入法面板，之后注销重新登陆即可现实和系统主题一致的输入法面板主题了。 双显卡显卡驱动方案\r安装驱动及bbswitch\r安装时记得选择和自己内核版本一致的nvidia显卡驱动，一般来说越新越好 1sudo pacman -S nvidia bbswitch 切换方案\r本切换方案采用archwiki中的解决方法 1yay -S optimus-manager-qt-kde 安装好之后记得使optimus-manager-qt-kde能够登陆自启动 ** 注意 **\n安装后阿可能有打不开steam的情况，记得安装libGL相关的包，一般是缺失例如lib32-nvidia-440xx-utils的包，记得选择和自己安装的相关的包哦\n触控板\r由于xf86-input-synaptics驱动已经停止了维护工作， - 所以manjaro官方把触控板驱动换成了支持wayland的libinput，但是默认情况下xorg（我目前用的）中的plasma桌面的设置中触控板管理工具无法完成libinput触控板驱动的实时配置，所以根据arch wiki的指示下安装了支持实时配置libinput的图形化工具kcm-pointing-devices-git（aur中,其他桌面就智者见智吧），\n安装后即可，命令\n1#没有aur工具的话就先安装yay或者yaourt 2 3sudo pacman -S yay 4 5 6#然后再安装lininput 7 8 9yay -S kcm-pointing-devices-git 即可重新完成对触控板的特性支持，包括轻触，按键模拟等特性\n然后自己配置就行。\nimpressionyang","date":"February 18, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/tech_and_skill/manjaro-install-config/","series":[{"title":"博客","url":"/series/%E5%8D%9A%E5%AE%A2/"}],"smallImg":"","tags":[{"title":"skill","url":"/tags/skill/"},{"title":"archlinux","url":"/tags/archlinux/"},{"title":"install","url":"/tags/install/"}],"timestamp":1582069279,"title":"MANJARO KDE安装配置(已换Arch Linux，此贴可能废弃)"},{"authors":[],"categories":[],"content":"歌单分享\r说明一下，霉霉的歌在app里面是听正版的，但是在网页上想听也没办法 impressionyang","date":"February 18, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/about/music/","series":[],"smallImg":"","tags":[],"timestamp":1582067196,"title":"歌单分享"},{"authors":[],"categories":[],"content":"\r个人简介\r姓名： 杨显运\n性别： 男\n个人介绍\r一个技术小白，日常使用Linux系统作为主力系统，目前使用Arch Linux，使用过Ubuntu、Debian、\rmint、manjaro以及deepin。个人不太喜欢Windows或者臃肿并且不高效的平台或者桌面进行开发，\r开发中喜欢“投机取巧”完成程序功能，没有一招鲜，只有随机应变才是完成任务的最佳方案！\n熟练使用的编程语言有C、C++、Java，使用过Python、HTML5、CSS、JavaScript、Shell的基本语法编程\r会使用Java配合Android Studio进行安卓程序的开发（基本图形面，简单多线程，handler，数据库，socket）\r会使用C/C++配合Qt Creator使用Qt图形界面框架进行C/C++的图形界面开发（基本图形界面，简单多线程，\r自定义widget，数据库，socket）\n日常使用工具\r编程用工具：VSCode、Qt Ceator、Eclipse、Android Studio、Code Blocks\n文本文档： Kate、Typora、Zeal\n图形图像： Gimp、inkscape\n好玩的个人github项目\rOracle Java8自动安装脚本 Qt GUI(非QML)界面项目创建脚手架 Qt Linux系统监视器(残废中) Deeppin Linux DTK框架入门 自己的第一个Qt小项目-计算器 求职意向\r无 ","date":"February 18, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/about/about/","series":[],"smallImg":"","tags":[],"timestamp":1582067196,"title":"个人简介"},{"authors":[],"categories":[{"title":"talk","url":"/categories/talk/"}],"content":"本页面主要内容为本站的一些置顶的重要信息\n当前无重要信息发出\n文档大概分类\rcategories\r分为三种分类 日常类,categories=daily 编程类,categories=program 技巧类,categories=skill 培训学习类，catagories=learn tag\r下面是主标签，每个帖子会发布多标签，一般为主标签+具体标签 第一个标签（主标签）就是帖子的分类 日常类,tag=daily,\u0026hellip; 编程类,tag=program,\u0026hellip; 技巧类,tag=skill,\u0026hellip; 具体分类\r日常 技术 技巧 记事(text) 编程语言(具体的语言) 便捷操作(具体的操作) \u0026hellip; 编程工具(具体的工具) 操作系统日常(Linux)(具体操作) \u0026hellip; \u0026hellip; \u0026hellip; 文章查找\r直接搜索关键词\r在首页可以点击博客网站的顶部的搜索按钮进行关键词搜索\n归档\r在任意页面博客站顶部的文章-\u0026gt;归档进行上传日期为索引的文章检索\n标签和分类\r在任意页面博客站顶部的文章-\u0026gt;分类/标签进行以 分类/标签 为索引的文章检索\nimpressionyang","date":"February 18, 2020","img":"","lang":"zh-cn","langName":"简体中文","largeImg":"","permalink":"/posts/talk/first-begin/","series":[],"smallImg":"","tags":[{"title":"daily","url":"/tags/daily/"},{"title":"text","url":"/tags/text/"}],"timestamp":1582062312,"title":"置顶公告（点击查看详情）"}]
